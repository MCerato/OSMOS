[SystemInfo]
Firmware=DMC4183s56g
Serial=15942.0000
Device=DMC41x3
Axis=8

[Configuration]
EO=false
VF=VF 10.4\r
PF=PF 10.0\r
LZ=LZ 1\r
MT\size=8
MT\1\Cmd="MTA=2.0\r"
MT\2\Cmd="MTB=2.0\r"
MT\3\Cmd="MTC=2.0\r"
MT\4\Cmd="MTD=2.0\r"
MT\5\Cmd="MTE=2.0\r"
MT\6\Cmd="MTF=2.0\r"
MT\7\Cmd="MTG=2.0\r"
MT\8\Cmd="MTH=2.0\r"
GA\size=0
BA\size=1
BA\1\Cmd=BA N\r
CE="CEA=4\rCEB=4\rCEC=4\rCED=4\rCEE=4\rCEF=4\rCEG=4\rCEH=4\r"
AF="AFA=0\rAFB=0\rAFC=0\rAFD=0\rAFE=0\rAFF=0\rAFG=0\rAFH=0\r"
DV="DVA=1\rDVB=0\rDVC=0\rDVD=0\rDVE=0\rDVF=0\rDVG=0\rDVH=0\r"
BR="BRA=0\rBRB=0\rBRC=0\rBRD=0\rBRE=0\rBRF=0\rBRG=0\rBRH=0\r"
FL="FLA=2147483647\rFLB=2147483647\rFLC=2147483647\rFLD=2147483647\rFLE=2147483647\rFLF=2147483647\rFLG=2147483647\rFLH=2147483647\r"
BL="BLA=-2147483648\rBLB=-2147483648\rBLC=-2147483648\rBLD=-2147483648\rBLE=-2147483648\rBLF=-2147483648\rBLG=-2147483648\rBLH=-2147483648\r"
CL="CLA=0\rCLB=0\rCLC=0\rCLD=0\rCLE=0\rCLF=0\rCLG=0\rCLH=0\r"
SI="SIA=0,0,0,0<0>0\rSIB=0,0,0,0<0>0\rSIC=0,0,0,0<0>0\rSID=0,0,0,0<0>0\rSIE=0,0,0,0<0>0\rSIF=0,0,0,0<0>0\rSIG=0,0,0,0<0>0\rSIH=0,0,0,0<0>0\r"
SS="SSA=0,0,0,0<0\rSSB=0,0,0,0<0\rSSC=0,0,0,0<0\rSSD=0,0,0,0<0\rSSE=0,0,0,0<0\rSSF=0,0,0,0<0\rSSG=0,0,0,0<0\rSSH=0,0,0,0<0\r"
DB="DBA=1\rDBB=1\rDBC=1\rDBD=1\rDBE=1\rDBF=1\rDBG=1\rDBH=1\r"
DS="DSA=1\rDSB=1\rDSC=1\rDSD=1\rDSE=1\rDSF=1\rDSG=1\rDSH=1\r"
BW="BWA=0\rBWB=0\rBWC=0\rBWD=0\rBWE=0\rBWF=0\rBWG=0\rBWH=0\r"
ZA="ZAA=0\rZAB=0\rZAC=0\rZAD=0\rZAE=0\rZAF=0\rZAG=0\rZAH=0\r"
KD="KDA=0.00\rKDB=0.00\rKDC=0.00\rKDD=0.00\rKDE=0.00\rKDF=0.00\rKDG=0.00\rKDH=0.00\r"
KI="KIA=0.0000\rKIB=0.0000\rKIC=0.0000\rKID=0.0000\rKIE=0.0000\rKIF=0.0000\rKIG=0.0000\rKIH=0.0000\r"
KP="KPA=0.00\rKPB=0.00\rKPC=0.00\rKPD=0.00\rKPE=4.00\rKPF=0.00\rKPG=0.75\rKPH=0.00\r"
K3="K3A=0.00\rK3B=0.00\rK3C=0.00\rK3D=0.00\rK3E=0.00\rK3F=0.00\rK3G=0.00\rK3H=0.00\r"
K2="K2A=0.000\rK2B=0.000\rK2C=0.000\rK2D=0.000\rK2E=0.000\rK2F=0.000\rK2G=0.000\rK2H=0.000\r"
K1="K1A=0.00\rK1B=0.00\rK1C=0.00\rK1D=0.00\rK1E=4.00\rK1F=0.00\rK1G=0.75\rK1H=0.00\r"
ZN="ZNA=0.0000\rZNB=0.0000\rZNC=0.0000\rZND=0.0000\rZNE=0.0000\rZNF=0.0000\rZNG=0.0018\rZNH=0.0000\r"
ZP="ZPA=0.0000\rZPB=0.0000\rZPC=0.0000\rZPD=0.0000\rZPE=0.0000\rZPF=0.0000\rZPG=0.0015\rZPH=0.0000\r"
CP="CPA=-1\rCPB=-1\rCPC=-1\rCPD=-1\rCPE=-1\rCPF=-1\rCPG=-1\rCPH=-1\r"
CT="CTA=0.0000\rCTB=0.0000\rCTC=0.0000\rCTD=0.0000\rCTE=0.0000\rCTF=0.0000\rCTG=0.0000\rCTH=0.0000\r"
IL="ILA=-9.9982\rILB=-9.9982\rILC=-9.9982\rILD=-9.9982\rILE=-9.9982\rILF=-9.9982\rILG=-9.9982\rILH=-9.9982\r"
TK="TKA=0.0000\rTKB=0.0000\rTKC=0.0000\rTKD=0.0000\rTKE=0.0000\rTKF=0.0000\rTKG=0.0000\rTKH=0.0000\r"
TL="TLA=9.9982\rTLB=9.9982\rTLC=9.9982\rTLD=9.9982\rTLE=9.9982\rTLF=9.9982\rTLG=9.9982\rTLH=9.9982\r"
OF="OFA=0.0000\rOFB=0.0000\rOFC=0.0000\rOFD=0.0000\rOFE=0.0000\rOFF=0.0000\rOFG=0.0000\rOFH=0.0000\r"
FA="FAA=0.00\rFAB=0.00\rFAC=0.00\rFAD=0.00\rFAE=0.00\rFAF=0.00\rFAG=0.00\rFAH=0.00\r"
FV="FVA=0\rFVB=40\rFVC=0\rFVD=0\rFVE=10\rFVF=0\rFVG=0\rFVH=0\r"
PL="PLA=0.0000\rPLB=0.0000\rPLC=0.0000\rPLD=0.0000\rPLE=0.0000\rPLF=0.0000\rPLG=0.0000\rPLH=0.0000\r"
IT="ITA=1.0000\rITB=1.0000\rITC=1.0000\rITD=1.0000\rITE=1.0000\rITF=1.0000\rITG=1.0000\rITH=1.0000\r"
NB="NBA=0.5\rNBB=0.5\rNBC=0.5\rNBD=0.5\rNBE=0.5\rNBF=0.5\rNBG=0.5\rNBH=0.5\r"
NF="NFA=0\rNFB=0\rNFC=0\rNFD=0\rNFE=0\rNFF=0\rNFG=0\rNFH=0\r"
NZ="NZA=0.0\rNZB=0.0\rNZC=0.0\rNZD=0.0\rNZE=0.0\rNZF=0.0\rNZG=0.0\rNZH=0.0\r"
AC="ACA=8192\rACB=8192\rACC=8192\rACD=8192\rACE=399360\rACF=99328\rACG=8192\rACH=5120\r"
DC="DCA=3072\rDCB=8192\rDCC=8192\rDCD=8192\rDCE=399360\rDCF=99328\rDCG=8192\rDCH=4096\r"
SP="SPA=1000\rSPB=2000\rSPC=800\rSPD=800\rSPE=200000\rSPF=5000\rSPG=17560\rSPH=2500\r"
PT="PTA=0\rPTB=0\rPTC=0\rPTD=0\rPTE=0\rPTF=0\rPTG=0\rPTH=0\r"
GD="GDA=0\rGDB=0\rGDC=0\rGDD=0\rGDE=0\rGDF=0\rGDG=0\rGDH=0\r"
GM="GMA=0\rGMB=0\rGMC=0\rGMD=0\rGME=0\rGMF=0\rGMG=0\rGMH=0\r"
GR="GRA=0.0000\rGRB=0.0000\rGRC=0.0000\rGRD=0.0000\rGRE=0.0000\rGRF=0.0000\rGRG=0.0000\rGRH=0.0000\r"
AG="AGA=1\rAGB=1\rAGC=1\rAGD=1\rAGE=1\rAGF=1\rAGG=1\rAGH=1\r"
AU="AUA=0.0\rAUB=0.0\rAUC=0.0\rAUD=0.0\rAUE=0.0\rAUF=0.0\rAUG=0.0\rAUH=0.0\r"
OE="OEA=0\rOEB=0\rOEC=0\rOED=0\rOEE=0\rOEF=0\rOEG=0\rOEH=0\r"
ER="ERA=0\rERB=0\rERC=0\rERD=0\rERE=0\rERF=0\rERG=1200\rERH=0\r"
LD="LDA=0\rLDB=0\rLDC=0\rLDD=0\rLDE=0\rLDF=0\rLDG=0\rLDH=0\r"
OA="OAA=0\rOAB=0\rOAC=0\rOAD=0\rOAE=0\rOAF=0\rOAG=0\rOAH=0\r"
OT="OTA=30\rOTB=30\rOTC=30\rOTD=30\rOTE=30\rOTF=30\rOTG=30\rOTH=30\r"
OV="OVA=0.9438\rOVB=0.9438\rOVC=0.9438\rOVD=0.9438\rOVE=0.9438\rOVF=0.9438\rOVG=0.9438\rOVH=0.9438\r"
OW="OWA=0\rOWB=0\rOWC=0\rOWD=0\rOWE=0\rOWF=0\rOWG=0\rOWH=0\r"
HV="HVA=256\rHVB=256\rHVC=256\rHVD=256\rHVE=256\rHVF=256\rHVG=256\rHVH=256\r"
SD="SDA=1073740800\rSDB=1073740800\rSDC=1073740800\rSDD=1073740800\rSDE=1073740800\rSDF=1073740800\rSDG=1073740800\rSDH=1073740800\r"
TW="TWA=32766\rTWB=32766\rTWC=32766\rTWD=32766\rTWE=32766\rTWF=32766\rTWG=32766\rTWH=32766\r"
BB="BBA=0.00\rBBB=0.00\rBBC=0.00\rBBD=0.00\rBBE=0.00\rBBF=0.00\rBBG=0.00\rBBH=0.00\r"
BI="BIA=0\rBIB=0\rBIC=0\rBID=0\rBIE=0\rBIF=0\rBIG=0\rBIH=0\r"
BM="BMA=2000.0000\rBMB=2000.0000\rBMC=2000.0000\rBMD=2000.0000\rBME=2000.0000\rBMF=2000.0000\rBMG=2000.0000\rBMH=2000.0000\r"
BO="BOA=0.0000\rBOB=0.0000\rBOC=0.0000\rBOD=0.0000\rBOE=0.0000\rBOF=0.0000\rBOG=0.0000\rBOH=0.0000\r"
LC="LCA=0\rLCB=0\rLCC=0\rLCD=0\rLCE=0\rLCF=0\rLCG=0\rLCH=0\r"
KS="KSA=0.500\rKSB=2.000\rKSC=2.000\rKSD=2.000\rKSE=2.000\rKSF=2.000\rKSG=2.000\rKSH=2.000\r"
YA="YAA=1\rYAB=1\rYAC=1\rYAD=1\rYAE=1\rYAF=1\rYAG=1\rYAH=1\r"
YB="YBA=1\rYBB=1\rYBC=1\rYBD=1\rYBE=1\rYBF=1\rYBG=1\rYBH=1\r"
YC="YCA=1\rYCB=1\rYCC=1\rYCD=1\rYCE=1\rYCF=1\rYCG=1\rYCH=1\r"
VA="VAS=8192\rVAT=8192\r"
VD="VDS=8192\rVDT=8192\r"
VS="VSS=25000\rVST=25000\r"
IA="IA 172,16,3,67\r"
SM="SM 0,0,0,0\r"
DH=DH 0\r
IK=IK 1\r
TM=TM 1000.0000\r
EI=EI 0.0000\r
AQ1="AQ 1,2.0000\r"
AQ2="AQ 2,2.0000\r"
AQ3="AQ 3,2.0000\r"
AQ4="AQ 4,2.0000\r"
AQ5="AQ 5,2.0000\r"
AQ6="AQ 6,2.0000\r"
AQ7="AQ 7,2.0000\r"
AQ8="AQ 8,2.0000\r"
CW=CW 1.0000\r
CN0=CN 1.0000\r
CN1="CN ,-1.0000\r"
CN2="CN ,,-1.0000\r"
CN3="CN ,,,0.0000\r"
CN4="CN ,,,,0.0000\r"
MO\size=1
MO\1\Cmd=MO\r

[Data]
Variable\size=49
Variable\1\Name=ActuPaCh
Variable\1\Value=-317001.0000
Variable\2\Name=ActualPa
Variable\2\Value=-317001.0000
Variable\3\Name=BckDbwA
Variable\3\Value=1.0000
Variable\4\Name=BckDbwB
Variable\4\Value=1.0000
Variable\5\Name=BckDbwC
Variable\5\Value=1.0000
Variable\6\Name=BckDbwD
Variable\6\Value=1.0000
Variable\7\Name=BckDbwE
Variable\7\Value=1.0000
Variable\8\Name=BckDbwF
Variable\8\Value=1.0000
Variable\9\Name=BckDbwG
Variable\9\Value=1.0000
Variable\10\Name=BckDbwH
Variable\10\Value=1.0000
Variable\11\Name=CTA
Variable\11\Value=0.0000
Variable\12\Name=CTB
Variable\12\Value=0.0000
Variable\13\Name=CTC
Variable\13\Value=0.0000
Variable\14\Name=CTD
Variable\14\Value=0.0000
Variable\15\Name=CTE
Variable\15\Value=0.0000
Variable\16\Name=CTF
Variable\16\Value=0.0000
Variable\17\Name=CTG
Variable\17\Value=0.0000
Variable\18\Name=CTH
Variable\18\Value=0.0000
Variable\19\Name=CmdHvOk
Variable\19\Value=1.0000
Variable\20\Name=DcLimSwi
Variable\20\Value=1024000.0000
Variable\21\Name=Debug
Variable\21\Value=0.0000
Variable\22\Name=FstBoot
Variable\22\Value=0.0000
Variable\23\Name=GrpAxes
Variable\23\Value=0.0000
Variable\24\Name=GrpCmd
Variable\24\Value=0.0000
Variable\25\Name=LastAxis
Variable\25\Value=-1.0000
Variable\26\Name=McRevGen
Variable\26\Value=50462721.0000
Variable\27\Name=McRevSpe
Variable\27\Value=0.0000
Variable\28\Name=OldGrpAx
Variable\28\Value=-1.0000
Variable\29\Name=PomSpBck
Variable\29\Value=1000.0000
Variable\30\Name=PomSpeed
Variable\30\Value=1000.0000
Variable\31\Name=SpMini
Variable\31\Value=32.0000
Variable\32\Name=TempAx
Variable\32\Value=0.0000
Variable\33\Name=TstCmdEr
Variable\33\Value=0.0000
Variable\34\Name=ValInc
Variable\34\Value=0.0000
Variable\35\Name=i
Variable\35\Value=3.0000
Variable\36\Name=i16
Variable\36\Value=19.0000
Variable\37\Name=i24
Variable\37\Value=24.0000
Variable\38\Name=i8
Variable\38\Value=11.0000
Variable\39\Name=iBit
Variable\39\Value=8.0000
Variable\40\Name=iPE
Variable\40\Value=0.0000
Variable\41\Name=iPE8
Variable\41\Value=8.0000
Variable\42\Name=iPom
Variable\42\Value=0.0000
Variable\43\Name=iPom8
Variable\43\Value=8.0000
Variable\44\Name=iRem
Variable\44\Value=0.0000
Variable\45\Name=nbAxes
Variable\45\Value=8.0000
Variable\46\Name=nbBl
Variable\46\Value=0.0000
Variable\47\Name=nbFh
Variable\47\Value=0.0000
Variable\48\Name=nbFi
Variable\48\Value=0.0000
Variable\49\Name=nbFl
Variable\49\Value=0.0000
Array\size=22
Array\1\Name=AssBckup
Array\1\Size=8
Array\1\Value=1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 2.0000, 1.0000
Array\2\Name=AssConf
Array\2\Size=320
Array\2\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.0000, 1000.0000, 0.0003, 0.0006, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 40.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 4.0000, 0.0000, 0.0000, 4.0000, 0.0000, 0.0000, 10.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.0000, 1100.0000, 0.0009, 0.0012, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.0000, 1200.0000, 0.0015, 0.0018, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 40.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.8000, 0.0000, 0.0000, 0.0000, 1300.0000, 0.0021, 0.0024, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\3\Name=Bck
Array\3\Size=8
Array\3\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\4\Name=Cmd
Array\4\Size=8
Array\4\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\5\Name=CpMp
Array\5\Size=24
Array\5\Value=32768.0000, 32769.0000, 32769.0000, 32768.0000, 32768.0000, 32769.0000, 32769.0000, 32768.0000, 32768.0000, 32769.0000, 32769.0000, 32768.0000, 32768.0000, 32769.0000, 32769.0000, 32768.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\6\Name=Dbw
Array\6\Size=16
Array\6\Value=1.0000, 1.0000, 0.0100, 0.0000, 0.0000, 0.0000, 0.0000, 2.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000
Array\7\Name=DcOld
Array\7\Size=8
Array\7\Value=3072.0000, 8192.0000, 8192.0000, 8192.0000, 8192.0000, 8192.0000, 8192.0000, 8192.0000
Array\8\Name=EnRem
Array\8\Size=16
Array\8\Value=1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\9\Name=GrAxis
Array\9\Size=8
Array\9\Value=-1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000
Array\10\Name=GrRatio
Array\10\Size=8
Array\10\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\11\Name=GrTemp
Array\11\Size=24
Array\11\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\12\Name=IniPos
Array\12\Size=8
Array\12\Value=595999.2800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\13\Name=IniSpeed
Array\13\Size=8
Array\13\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\14\Name=IniTyp
Array\14\Size=8
Array\14\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\15\Name=ModAss
Array\15\Size=8
Array\15\Value=1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 2.0000, 1.0000
Array\16\Name=NbRetry
Array\16\Size=8
Array\16\Value=5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 5.0000
Array\17\Name=Percent
Array\17\Size=8
Array\17\Value=1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000
Array\18\Name=Pos
Array\18\Size=8
Array\18\Value=-314001.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\19\Name=PosStat
Array\19\Size=16
Array\19\Value=2.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\20\Name=SpBackup
Array\20\Size=24
Array\20\Value=1000.0000, 800.0000, 800.0000, 800.0000, 800.0000, 800.0000, 800.0000, 800.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 2000.0000, 800.0000, 800.0000, 800.0000, 800.0000, 800.0000, 800.0000, 800.0000
Array\21\Name=StabTime
Array\21\Size=32
Array\21\Value=100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 881060442.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 1000.0000, 1000.0000, 1000.0000, 1000.0000, 1000.0000, 1000.0000, 1000.0000, 1000.0000, 881061342.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\22\Name=Stat
Array\22\Size=8
Array\22\Value=66656.0000, 65762.0000, 65762.0000, 65760.0000, 65760.0000, 65762.0000, 65762.0000, 65760.0000

[Program]
Program="'************************************************************************\n'*                                                                      *\n'*              Microcode generique V3.2                                *\n'*                                                                      *\n'************************************************************************\n'*   Microcode Generique :      Version :  3.2.0.1                      *\n'*                              Date :     19-08-2016                   *\n'*                              Auteur :   B. Gombert/M. Cerato         *\n'*      Dernieres modifications :                                       *\n'*      =======================                                         *\n'* 3.2.0.2 - Application des param. du mode par dfaut au dmarrage     *\n'*         - Si DB/DS incoherents au demarrage, valeur par dfaut  1   *\n'* 3.2.0.1 - Ajout de ZP/ZN comme parametres MultiPID                   *\n'*         - reorg. adressage du tableau MultiPID                       *\n'* 3.2.0.0 - retrait de DB comme parametre MultiPID                     *\n'*         - reorg. adressage du tableau MultiPID                       *\n'*         - Reprise du fonctionnement de l'accuracy                    *\n'* 3.1.0.0 - Mise en oeuvre du multi PID                                *\n'*         - Initialisation de SD a valeur max                          *\n'* 3.0.0.0 - Mise en oeuvre de la "stepper-continuous-closed-loop".     *\n'*           necessite un firmware DMC4183s56b.hex ou ulterieur.        *\n'*         - Restauration de la deceleration apres un SD                *\n'*         - Activation CCLS (Definition CL=1) sur Motor On (step+cod). *\n'*         - Desactivation CCLS (CL=0) sur changement CpMp(sans codeur) *\n'*         - Remontee etat CCLS dans Stat-Closed_loop_active ($40000).  *\n'*         - Prise d'origine Stepper avec codeur desormais faite en CCLS*\n'*         - Ajout d'un timeout "positionnement trop long"              *\n'*         - "Percent", "Maintenance position", "Retry",                *\n'*           "Lock position" supprimes (variables declarees).           *\n'*         - YA YB YC forces a 1 a l'initialisation                     *\n'*         - integration codeur absolu dans CpMp pour etat Tango INIT   *\n'*         - Ajout d'une synchronisation des cmd/codeur sur butees      *\n'* 2.4.0.2 - Suppression des commentaires de la boucle principale afin  *\n'*           d'ameliorer le temps de cycle.                             *\n'*         - Correction d'une erreur mineure de syntaxe dans #CMDPOM.   *\n'*         - Ajout de la variable nbAxis pour parametrer le nombre      *\n'*           d'axes ControlBox.                                         *\n'* 2.4.0.1 - Ajout du forcage de la vitesse mini a 32cnt/s (SpMini)     *\n'*           sur les commandes de Jog (Forward - Backward).             *\n'* 2.4.0.0 - Ajout du support de la property AxisInitSpeed via          *\n'*           IniSpeed[] pour definir la vitesse de prise d'origine.     *\n'* 2.3.0.7 - Modification de la syntaxe de la routine #LIMSWI,          *\n'*           reduction du nombre de IF empiles.                         *\n'* 2.3.0.6 - Correction des lenteurs microcode lorsqu'une erreur de     *\n'*           poursuite est excessive sur un servomoteur (cf. #POSERR).  *\n'* 2.3.0.5 - Ajout de la fonctionnalite "Correction de l'erreur         *\n'*           statique de position des moteurs pas-a-pas".               *\n'* 2.3.0.4 - Ajout de la fonctionnalite "Commande Groupee"              *\n'*         - Autorisation de la commande Stop meme si le mouvement est  *\n'*           interdit au Device (Stat[]_bit6).                          *\n'* 2.3.0.3 - Ajout de la fonction SettlingTime : remplacement de la     *\n'*           variable TempStab par le tableau StabTime[].               *\n'*         - Amelioration des arrondis sur les DefinePosition et        *\n'*           consignes de Position (ajout de @RND).                     *\n'* 2.3.0.2 - Modification de la routine #POSCHK et de la tache #PECORR  *\n'*           pour eviter qu'un positionnement stoppe a bas niveau       *\n'*           (terminal) ne soit relance.                                *\n'*         - Modification de la commande de STOP pour stopper une       *\n'*           eventuelle correction d'erreur de poursuite.               *\n'* 2.3.0.1 - Modification de la routine #CMDERR pour le traiter les     *\n'*           erreurs des threads specifiques (amelioration de           *\n'*           l'integration des microcodes specifiques).                 *\n'*         - Utilisation de la variable "LastAxis" pour pointer les     *\n'*           axes mis en mouvement par les threads specifiques.         *\n'************************************************************************\n'*   Microcode Specifique :      Version :   -                          *\n'*                               Date :      -                          *\n'*                               Auteur :    -                          *\n'**************************** Commentaires ******************************\n'* -les variables de type "~x" sont des pointeurs d'axe                 *\n'*  "~x" peut prendre les valeurs 0 a 7 pour designer les axes A a H    *\n'*   ~a - pointeur d'axe de la boucle principale                        *\n'*   ~b - pointeur d'axe de la tache de prise d'origine                 *\n'*   ~c - pointeur d'axe de la routine automatique #POSERR              *\n'*   ~d - pointeur d'axe de la routine automatique #LIMSWI              *\n'*   ~e - disponible                                                    *\n'*   ~f - disponible                                                    *\n'*   ~g - disponible                                                    *\n'*   ~h - disponible                                                    *\n'* -les variables de type "iXX" sont des pointeurs de tableaux          *\n'******************************* Taches *********************************\n'* 0- Tache principale executee automatiquement a la mise sous tension  *\n'* 1- Tache dediee aux prises d'origines                                *\n'* 2- Tache reservee au microcode generique                             *\n'* 3- Tache reservee au microcode generique                             *\n'* 4- Tache reservee aux microcodes specifiques                         *\n'* 5- Tache reservee aux microcodes specifiques                         *\n'* 6- Tache reservee aux microcodes specifiques                         *\n'* 7- Tache reservee aux microcodes specifiques                         *\n'************************************************************************\n'\n#AUTO\n'\nMcRevGen=$03020001;'   Version Microcode Generique\n'\nMcRevSpe=$00000000;'   Version Microcode Specifique\n'\nDA*[];'             Desallocation des tableaux en memoire\n' Declaration des tableaux :\n'\n' ******Tableaux necessaires aux device*****\nDM Stat[8];'        Etat de l'axe\nDM Cmd[8];'         Commande a executer\nDM IniTyp[8];'      Type d'initialisation\nDM IniPos[8];'      Valeur de la position initialisee\nDM IniSpeed[8];'    Valeur de la vitesse d'initialisation\nDM Pos[8];'         Position a atteindre\nDM Dbw[16];'        Dead BandWidth = precision du positionnement\nDM Bck[8];'         Backlash\n'\n'\nDM PosStat[16];'    (0  a 7  : Etat du positionnement                )\n'                   (8  a 15 : Prise d'origine sur une butee en cours)\nDM NbRetry[8];'     *** INUTILISE Maintenu pour retro-compatibilite ***\nDM Percent[8];'     *** INUTILISE Maintenu pour retro-compatibilite ***\nDM StabTime[32];'   Parametres d'attende de stabilisation du positionnement\n'                   (0  a 7  : Duree de stabilisation en ms)\n'                   (8  a 15 : Timer de stabilisation      )\n'                   (16 a 23 : Timeout de positionnement   )\n'                   (24 a 31 : Timer de timeout de posnmt  )\n'\n'\nDM ModAss[8];'      choix d asservissement\nDM AssBckup[8];'      Sauvegarde du choix d asservissement\n'\nDM AssConf[320]; '   Configuration des asservissements\n'\nDM SpBackup[24];'   Vitesses memorisees\n'                   (0  a 7  : correction d'erreur de position et mode Gearing)\n'                   (8  a 15 : vitesse en mode JOG                            )\n'                   (16 a 23 : vitesse en mode REMOTE\nDM DcOld[8];'  Old values of Deceleration Values                       )\nDM GrAxis[8];'      Axe maitre en mode gearing\nDM GrRatio[8];'     Ratio maitre/esclave en mode gearing\nDM GrTemp[24];'     Variable de traitement du mode Gearing\n'                   (0  a 7  : Variable temporaire traitement mode Gearing)\n'                   (8  a 15 : Axe maitre actif                           )\n'                   (16 a 23 : Gear ratio applique                        )\nDM CpMp[24];'       Presence Codeur et Maintenance de la Position\n'                   (0  a 7  : Valeurs actuelles de CpMp[])\n'                   (8  a 15 : Anciennes valeurs de CpMp[])\n'                   (16 a 23 : Anciennes valeurs de _CL)\nDM EnRem[16];'      Enable Remote\n'                   (0 a 7  : Activation/Desactivation du mode Remote)\n'                   (8 a 15 : Etat des axes en remote (ON/OFF)       )\n'\n' Constantes de parametrage du fonctionnement :\nSpMini=32;'         Vitesse de rotation minimum\nDcLimSwi=1024000;'  Deceleration minimum lors de l'activation d'une butee\nnbAxes=8;'          Parametrage du nombre d'axe dun controleur (1 a 8)\nDebug=0;'           Mode DEBUG desactive par defaut\n'\n' Detection support du HV par le controlleur (DMC-41x3)\nTstCmdEr=58;'        Declaration test sur operande inexistante pour #CMDERR\nCmdHvOk=1\nJP#HV_OK,(_HVA>-1)\nCmdHvOk=0\n#HV_OK\n' Detection premiere execution du code\nTstCmdEr=9;'        Declaration test sur variable non declaree pour #CMDERR\nJP#FSTBOOT,(FstBoot=0)\nFstBoot=1;'         Declaration 1er boot en cours\n#FSTBOOT\nTstCmdEr=0;'        Declaration fin test variable ou operande pour #CMDERR\n'\nJS#INIT;'           Appel de la routine d'initialisation\nJS#INITSPE;'        Appel de la routine d'init des variables specifiques\nFstBoot=0;'         Declaration 1er boot realise\ni=0;i8=8;i16=16;iBit=1;~a=0;'          Initialisation pointeurs d'axes\niPom=0;iPom8=8;iRem=0;iPE=0;iPE8=8;'   Initialisation des differents index\n'\n'============================== Boucle principale =============================\n' Routine CPMP :     Si CpMp modifie, appel de la routine CpMp\n' Routine CCL :      Si codeur present, activation Close Loop\n' Routine SETASS :   Selection du type d'asservissement\n' Routine SPE_SEQ :  Appel sequentiel de la routine specifique (optionnelle)\n' Routine CMD :      Appel de la routine d'execution des commandes\n' Routine POSCHK :   Si positionnement termine, controle\n' Routine REMOTE :   Si mode Remote autorise, execution de la routine\n'\n#MLOOP\n   JS#CPMP,(CpMp[i]<>CpMp[i8])\n   JS#CCL,(_CL~a<>CpMp[i16])\n   JS#SETASS,(ModAss[i]<>AssBckup[i])\n   JS#CMD,Cmd[i]<>0\n   JS#POSCHK,(PosStat[i]>0)&(_BG~a=0)\n   JS#REMOTE,(CpMp[i]&$8>0)\n   i=i+1;i8=i8+1;i16=i16+1;iBit=iBit*2;~a=i\nJP#MLOOP,i<nbAxes\ni=0;i8=8;i16=16;iBit=1;~a=0\nJP#MLOOP\nEN\n'============================ Fin Boucle principale ===========================\n'\n'===== Initialisation des variables =====\n#INIT\ni=0;i8=8;i16=16;~a=0;' Initialisation pointeur de tableau et pointeur d'axe\nJS#INITASS;          ' Initialisation table de PIDs\n'\n#ILOOP\n'\n'*** Parametres microcode ***\nPos[i]=0;'            Position a atteindre\nIF(FstBoot=1);'       Calcul du Dead Band Ratio seulement au premier demarrage\n   Dbw[i8]=0;'           Stabilization Dead Band Ratio par defaut\n   IF((_DB~a>0)&(_DS~a>0)); ' si aucun param. de dead band n'est nul\n      Dbw[i8]=_DS~a/_DB~a;' Stabilisation Dead Band Ratio =DS/DB\n   ELSE;IF((_DB~a>0)&(_DS~a>1)); 'Si DS est nul\n      DS~a=_DB~a;' placement de DS  la valeur de DB\n      Dbw[i8]=_DS~a/_DB~a;' Stabilisation Dead Band Ratio =DS/DB\n'\n'########Partie a tester sur Airbearing!!!!!########\n   ELSE; 'Si DB est nul\n      DB~a=1;DS~a=_DB~a;' placement de DS et DB  1\n      Dbw[i8]=_DS~a/_DB~a;' Stabilisation Dead Band Ratio =DS/DB\n   ENDIF;ENDIF\n'###################################################\nDbw[i]=_DB~a;'        Dead BandWidth = precision du positionnement\nENDIF\n'\nYA~a=1;YB~a=1;YC~a=1;'Initialisation des YABC pour CCLS\n'\nIF (CmdHvOk=1);SD~a=1073740800;ENDIF\n'      Verification de la presence d'une DMC4183\n'Initialisation du Switch Deceleration valeur max\n'\nBck[i]=0;'            Backlash nul par defaut\nPosStat[i]=0;'        Pas de mouvement en cours au demarrage\nPosStat[i8]=0;'       Pas de Prise d'origine sur une butee en cours\nStabTime[i]=100;'     Valeur d'attente de stabilisation du positionnement (ms)\nStabTime[i16]=1000;'  Valeur de Timeout du positionnement (ms)\nSpBackup[i]=_SP~a;'   Vitesse memorisee pour correction d'erreur de position\nSpBackup[i8]=0;'      Parametre memorise du mode jog\nSpBackup[i16]=_SP~a;' Vitesse memorise pour mode remote\nDcOld[i]=_DC~a;'      Storing current values of deceleration values into array\nStat[i]=$E0;'         Etat par defaut :\n'                     OnOff_autorise_au_device = 1     ($20)\n'                     Mouvement_autorise_au_device = 1 ($40)\n'                     Positionnement_termine = 1       ($80)\nCmd[i]=0;'            Commandes : pas de commande en cours\nIniTyp[i]=0;'         Prise de ref par defaut, faite sur Define Position DP\nIniPos[i]=0;'         Valeur de la position utilisee lors de la prise de ref\nGrAxis[i]=-1;'        Pas d'axe maitre en mode gearing au demarrage\nGrRatio[i]=0;'        Ratio maitre/esclave en mode gearing nul\nGrTemp[i8]=-1;'       Pas d'axe actif en mode gearing au demarrage\nGrTemp[i16]=0;'       Gear ratio nul au demarrage\nEnRem[i]=1;'          Mode remote autorise par le Microcode\n'\nAssBckup[i]=0;'       sauvegarde du mode en cours\nAssConf[i]=0;'        Table de configuration des PID (voir ligne 700)\nTempAx=0;'            pointeur virtuel d'axe\nValInc=0;'            Pointeur adresse de configuration asservissement\n'\nStat[i]=(Stat[i]&@COM[$1])|(@ABS[_MT~a]=1);' MaJ du type de moteur dans Stat\nCpMp[i]=0;'           CpMp : NO codeur, NO maintenance pos, NO remote\nCpMp[i8]=-1;'         Forcage de la mise a jour des parametres associes a CpMp\nCpMp[i16]=-1;'        Forcage de la mise a jour des parametres associes a _CL\n'\nJS#SETASS\n'\ni=i+1;i8=i8+1;i16=i16+1;~a=i;' Increment pointeur de tableau et pointeur d'axe\nJP#ILOOP,(i<nbAxes)\n'\nIF(FstBoot=1);'       Stockage du Dead Band Ratio au premier demarrage\n   BckDbwA=Dbw[8] ;BckDbwB=Dbw[9] ;BckDbwC=Dbw[10];BckDbwD=Dbw[11]\n   BckDbwE=Dbw[12];BckDbwF=Dbw[13];BckDbwG=Dbw[14];BckDbwH=Dbw[15]\nELSE;'                Restore du Dead Band Ratio aux demarrages suivants\n   Dbw[8]=BckDbwA ;Dbw[9]=BckDbwB ;Dbw[10]=BckDbwC;Dbw[11]=BckDbwD\n   Dbw[12]=BckDbwE;Dbw[13]=BckDbwF;Dbw[14]=BckDbwG;Dbw[15]=BckDbwH\nENDIF\nEN\n'\n'===== Execution des commandes =====\n#CMD\nIF((Cmd[i]&1)<>0);JS#CMDST;'                                Stop\nELSE;IF((Cmd[i]&2)<>0);JgDir= 1;JS#CMDJG,(Stat[i]&$40)<>0;' Jog +\nELSE;IF((Cmd[i]&4)<>0);JgDir=-1;JS#CMDJG,(Stat[i]&$40)<>0;' Jog -\nELSE;IF((Cmd[i]&$8)<>0);JS#CMDPOS,(Stat[i]&$40)<>0;'      Positionnement\nELSE;IF((Cmd[i]&$10)<>0);JS#CMDPOM,(Stat[i]&$40)<>0;'       Prise d'Origine Axe\nELSE;IF((Cmd[i]&$20)<>0);JS#CMDSH,(Stat[i]&$20)<>0;'        Motor On\nELSE;IF(((Cmd[i]&$40)<>0)&((Stat[i]&$20)<>0));MO~a;'        Motor Off\nELSE;IF((Cmd[i]&$80)<>0);JS#CMDGEAR;'                       Mise a jour Gearing\nENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF\nCmd[i]=0;'                                                  Commande traitee\nEN\n'\n'=========== Commande Stop ===========\n#CMDST\nIF((_XQ1>=0)&(i=iPom));'            Si la tache de prise de ref est executee,\n   HX1;'                            Arret de la tache de prise de ref\n   Stat[i]=((Stat[i]|$880)&@COM[$300])\n'                                   MAJ bit Positionnement_termine = 1 ($80)\n'                                   MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'                                   MAJ bit Prise_Ref_en_cours = 0     ($200)\n'                                   MAJ bit Echec_Prise_Ref = 1        ($800)\n   PosStat[i8]=0;'                  Pas de Prise d'origine sur butee en cours\nENDIF\nST~a;'                              Arret de l'axe\nSpBackup[i8]=0;'                    Mode JOG off\nPosStat[i]=0;'                      Pas de positionnement en cours\nStat[i]=(Stat[i]|$80)&@COM[$1100];' MAJ bit Positionnement_termine = 1 ($80)\n'                                   MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'                                   MAJ bit Attente_de_correction = 0  ($1000)\nEN\n'\n'============ Commande Jog ============\n#CMDJG\nJS#SETCCL;'                    Activation CCL des Stepper avec Codeur\nDcOld[i]=_DC~a;'               Storing old value of deceleration\nIF(_SP~a<SpMini);SP~a=SpMini;ENDIF;'Verification vitesses trop faibles\nSpBackup[i8]=JgDir*_SP~a;'     Definition de la vitesse signee du Jog\nJG~a=SpBackup[i8];'            Commande du mouvement\nStat[i]=(Stat[i]&@COM[$2180]);' MAJ bit Positionnement_termine =0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur = 0  ($100)\n'                              MAJ bit Erreur_de_poursuite = 0     ($2000)\nBG~a;'                         Execution du mouvement\nEN\n'\n'========= Commande Motor ON ==========\n#CMDSH\nJS#SETCCL;'                    Activation CCL des Stepper avec Codeur\nSH~a;'                         Motor ON\nEN\n'\n'===== Commande de positionnement =====\n#CMDPOS\nJS#SETCCL;'                    Activation CCL des Stepper avec Codeur\nActualPa=_PA~a;'               Recuperation de la position moteur\nIF(@ABS[Pos[i]-ActualPa]<=Dbw[i]);' Si position actuelle dans la plage cible\n   Stat[i]=((Stat[i]|$80)&@COM[$2100]);' On ne bouge pas\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n'                              MAJ bit Erreur_de_poursuite = 0   ($2000)\nELSE;'                         Si position actuelle hors de la plage cible\nDcOld[i]=_DC~a;'               Storing old value of deceleration\n   Stat[i]=(Stat[i]&@COM[$2180]);' MAJ bit Positionnement_termine=0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n'                              MAJ bit Erreur_de_poursuite = 0   ($2000)\n   IF(_SP~a<SpMini);SP~a=SpMini;ENDIF;'Verification vitesses trop faibles\n   SpBackup[i]=_SP~a;'         Mise en memoire de la vitesse\n   ' Gestion du Backlash\n   ' Si (Pd-Pa+Bck) est du signe de Bck,\n   IF(((Bck[i]/@ABS[Bck[i]])*(ActualPa-Pos[i]))>0)\n      PosStat[i]=3;'           Declaration: positionmt avec backlash en cours\n      PA~a=(Pos[i]-Bck[i]);BG~a;' Positionnement avec Backlash\n   ELSE;'                      Si (Pd-Pa+Bck) n'est pas du signe de Bck,\n      PosStat[i]=2;'           Declaration: positionmt sans backlash en cours\n      PA~a=@RND[Pos[i]];BG~a;' Positionnement\n   ENDIF\n   SpBackup[i8]=0;'            Mode JOG off\nENDIF\n'\nEN\n'\n'===== Execution de la tache de Prise de Reference =====\n#CMDPOM\nIF(_XQ1<0);'                   Si tache de prise de ref non executee,\n   JS#SETCCL;'                    Activation CCL des Stepper avec Codeur\n   iPom=i;iPom8=i+8;~b=i;'        Mise en memoire pointeurs d'axe prise de ref\n   DcOld[iPom]=_DC~b;'            Storing old value of deceleration\n   XQ#POM,1;'                     Execution de la tache de prise de ref\nENDIF\nEN\n'\n'======= Tache de Prise d'Origine Axe =======\n#POM\nStat[iPom]=((Stat[iPom]|$200)&@COM[$2D80])\n'                              MAJ bit Positionnement_termine =0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n'                              MAJ bit Prise_Ref_en_cours= 1     ($200)\n'                              MAJ bit Prise_Ref_Faite = 0       ($400)\n'                              MAJ bit Echec_Prise_Ref = 0       ($800)\n'                              MAJ bit Erreur_de_poursuite = 0   ($2000)\nST~b;AM~b;'                    Arret de l'axe\nPosStat[iPom]=0;'              Pas de positionnement en cours\nSpBackup[iPom8]=0;'            Mode JOG off\nPosStat[iPom8]=0;'             Init pas de Prise d'origine sur butee en cours\nPomSpBck=_SP~b;'               Memorisation vitesse avant prise d'origine\nPomSpeed=_SP~b;'               Memorisation vitesse de prise d'origine\nIF(IniSpeed[iPom]>SpMini);PomSpeed=IniSpeed[iPom];ENDIF;'Property AxisInitSpeed\nnbBl=(IniTyp[iPom]&$F000)/$1000;'         Nombre de recherches de la Bwd Limit\nnbFl=(IniTyp[iPom]&$0F00)/$100;'          Nombre de recherches de la Fwd Limit\nnbFh=(IniTyp[iPom]&$0070)/$10;'           Nombre de recherches du capteur Home\nnbFi=(IniTyp[iPom]&$0007);'               Nombre de recherches de l'Index\nIF((IniTyp[iPom]&$F000)<>0);JS#POMBL;'       Prise d'origine sur Bwd Limit\nELSE;IF((IniTyp[iPom]&$0F00)<>0);JS#POMFL;'  Prise d'origine sur Fwd Limit\nENDIF;ENDIF\nIF((IniTyp[iPom]&$0070)<>0);JS#POMFH;ENDIF;' Prise d'origine sur Find Home\nIF((IniTyp[iPom]&$0007)<>0);JS#POMFI;ENDIF;' Prise d'origine sur Find Index\nIF(@ABS[_MT~b]<>1);'           Si moteur STEPPER\n   IF((CpMp[iPom]&1)>0);'      Si codeur INCREMENTAL\n      DP~b=IniPos[iPom];'      Init Position Principale\n   ELSE;IF((CpMp[iPom]&2)>0);' Si codeur ABSOLU\n      DP~b=_TP~b;'             Init Position Principale\n   ELSE;'                      Si PAS de codeur\n      DP~b=IniPos[iPom];'      Init Position Principale\n   ENDIF;ENDIF\nELSE;'                         Si moteur SERVO ou PIEZO\n   DP~b=IniPos[iPom];'         Init Position Principale\n   DE~b=0;'                    Init Position Auxiliaire\nENDIF\nStat[iPom]=((Stat[iPom]&@COM[$200])|$480)\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Prise_Ref_en_cours= 0     ($200)\n'                              MAJ bit Prise_Ref_Faite = 1       ($400)\nCpMp[iPom8]=CpMp[iPom];'       Mise en memoire de CpMp[iPom]\nEN\n'========= Fin Prise d'Origine Axe ==========\n'\n'** POM sur Backward Limit **\n#POMBL\nspBl=_SP~b;'                   Mise en memoire de la vitesse\niBl=0;'                        Index de la boucle BL (iterations)\nIF(IniSpeed[iPom]>SpMini);SP~b=IniSpeed[iPom];ENDIF;' Property AxisInitSpeed\n#BLLOOP\n   PosStat[iPom8]=-1;'         Prise d'origine sur la butee - en cours\n   IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n   lrStat=_LR~b;'              Mise en memoire de l'etat de la butee\n   IF(_LR~b);JG~b=-_SP~b;BG~b;'Limite inactive : recherche de la butee\n   ELSE;JG~b=_SP~b;BG~b;ENDIF;'Limite active : degagement de la butee\n#BLWAIT;JP#BLWAIT,(lrStat=_LR~b);' Attente changement etat butee\n   ST~b;AM~b;'                 Arret de l'axe apres front sur la butee\n   PomSpeed=_SP~b;'            Memorisation derniere vitesse prise d'origine\n   SP~b=_SP~b/5;'              Reduction de la vitesse a chaque iteration\n   iBl=iBl+1;'                 Increment de l'index de boucle BL\nJP#BLLOOP,iBl<nbBl;'           Iteration suivante\nSP~b=spBl;'                    Restauration de la vitesse\nWT StabTime[iPom];'            Attente de stabilisation\nPosStat[iPom8]=0;'             Pas de Prise d'origine sur butee en cours\nEN\n'** POM sur Forward Limit ***\n#POMFL\nspFl=_SP~b;'                   Mise en memoire de la vitesse\niFl=0;'                        Index de la boucle FL (iterations)\nIF(IniSpeed[iPom]>SpMini);SP~b=IniSpeed[iPom];ENDIF;' Property AxisInitSpeed\n#FLLOOP\n   PosStat[iPom8]=1;'          Prise d'origine sur la butee + en cours\n   IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n   lfStat=_LF~b;'              Mise en memoire de l'etat de la butee\n   IF(_LF~b);JG~b=_SP~b;BG~b;' Limite inactive : recherche de la butee\n   ELSE;JG~b=-_SP~b;BG~b;ENDIF;'Limite active : degagement de la butee\n#FLWAIT;JP#FLWAIT,(lfStat=_LF~b);'Attente changement etat butee\n   ST~b;AM~b;'                 Arret de l'axe apres front sur la butee\n   PomSpeed=_SP~b;'            Memorisation derniere vitesse prise d'origine\n   SP~b=_SP~b/5;'              Reduction de la vitesse a chaque iteration\n   iFl=iFl+1;'                 Increment de l'index de boucle FL\nJP#FLLOOP,iFl<nbFl;'           Iteration suivante\nSP~b=spFl;'                    Restauration de la vitesse\nWT StabTime[iPom];'            Attente de stabilisation\nPosStat[iPom8]=0;'             Pas de Prise d'origine sur butee en cours\nEN\n'**** POM sur Find Home *****\n#POMFH\nsgnFh=(IniTyp[iPom]&$0080)/$80;' Sens de rotation pour la recherche\nspFh=_SP~b;dirFh=sgnFh;'       Mise en memoire de la vitesse et du signe\niFh=0;'                        Index de la boucle FH (iterations)\nIF(IniSpeed[iPom]>SpMini);SP~b=IniSpeed[iPom];ENDIF;' Property AxisInitSpeed\n#FHLOOP\n   IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification vitesses trop faibles\n   hmStat=_HM~b;'              Mise en memoire de l'etat du capteur Home\n   IF(dirFh=0);JG~b=_SP~b;BG~b;'     Bit de signe positif : rotation +\n   ELSE;JG~b=-_SP~b;BG~b;ENDIF;'     Bit de signe negatif : rotation -\n#FHWAIT;JP#FHWAIT,(hmStat=_HM~b);'   Front sur HM ou butee\n   ST~b;AM~b;'                 Arret de l'axe apres front sur HM\n   PomSpeed=_SP~b;'            Memorisation derniere vitesse prise d'origine\n   SP~b=_SP~b/5;'              Reduction de la vitesse a chaque iteration\n   dirFh=(dirFh=0);'           Changement de direction (complement)\n   iFh=iFh+1;'                 Increment de l'index de boucle FH\nJP#FHLOOP,iFh<nbFh;'           Iteration suivante\nSP~b=spFh;'                    Restauration de la vitesse\nEN\n'**** POM sur Find Index ****\n#POMFI\nsgnFi=(IniTyp[iPom]&$0008)/$8;'Sens de rotation pour la recherche\nspFi=_SP~b;dirFi=sgnFi;'       Mise en memoire de la vitesse et du signe\nSP~b=PomSpeed;'                Utilisation derniere vitesse prise d'origine\niFi=0;'                        Index de la boucle FI (iterations)\n#FILOOP\n   IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n   IF(CmdHvOk);'               Si la commande HV est supportee,\n      HV~b=_SP~b/5;'              Vitesse de retour sur index latche reduite\n      IF(_HV~b<SpMini);HV~b=SpMini;ENDIF;'Verification vitesse HV trop faible\n   ENDIF\n   IF(dirFi=0);JG~b=_SP~b;'    Bit de signe positif : rotation +\n   ELSE;JG~b=-_SP~b;ENDIF;'    Bit de signe negatif : rotation -\n   FI~b;BG~b;'                 Lancement de la recherche d'index\n   AM~b;'                      Attente index trouve\n   SP~b=_SP~b/5;'              Reduction de la vitesse a chaque iteration\n   dirFi=(dirFi=0);'           Changement de direction (complement)\n   iFi=iFi+1;'                 Increment de l'index de boucle FI\nJP#FILOOP,iFi<nbFi;'           Iteration suivante\nSP~b=spFi;'                    Restauration de la vitesse\nEN\n'===== Fin Prise d'Origine Axe =====\n'\n'===== Commande de Mise a Jour du mode Gearing =====\n#CMDGEAR\nJS#SETCCL;'                    Activation CCL des Stepper avec Codeur\nIF((0<=GrAxis[i])&(GrAxis[i]<=7)&(GrAxis[i]<>i))\n   IF(GrAxis[i]=0);GA~a=A;ENDIF;'   Codeur Principal A Maitre\n   IF(GrAxis[i]=1);GA~a=B;ENDIF;'   Codeur Principal B Maitre\n   IF(GrAxis[i]=2);GA~a=C;ENDIF;'   Codeur Principal C Maitre\n   IF(GrAxis[i]=3);GA~a=D;ENDIF;'   Codeur Principal D Maitre\n   IF(GrAxis[i]=4);GA~a=E;ENDIF;'   Codeur Principal E Maitre\n   IF(GrAxis[i]=5);GA~a=F;ENDIF;'   Codeur Principal F Maitre\n   IF(GrAxis[i]=6);GA~a=G;ENDIF;'   Codeur Principal G Maitre\n   IF(GrAxis[i]=7);GA~a=H;ENDIF;'   Codeur Principal H Maitre\n   GR~a=GrRatio[i];'           Definition du Gear Ratio\n   GrTemp[i8]=GrAxis[i];'      Memorisation des axes maitres actifs\n   GrTemp[i16]=GrRatio[i];'    Memorisation du gear ratio applique\n   IF(Stat[i]&$4000=0);'       Si l'axe n'etait pas deja esclave\n      SpBackup[i]=_SP~a;'      Mise en memoire de la vitesse de l'axe esclave\n   ENDIF\n   Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'                              MaJ bit Axe_Esclave = 1           ($4000)\n'                              MaJ bit OnOff_Autorise = 0        ($20)\n'                              MaJ bit Mvmt_Autorise = 0         ($40)\n'                              MAJ bit Positionnement_termine =0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n   JG~a=0; BG~a;'              Definition d'un Jog nul sur l'axe esclave\nELSE;IF(GrAxis[i]=8)\n   GA~a=N;'                    Axe Virtuel N Maitre\n   GR~a=GrRatio[i];'           Definition du Gear Ratio\n   GrTemp[i8]=GrAxis[i];'      Memorisation des axes maitres actifs\n   GrTemp[i16]=GrRatio[i];'    Memorisation du gear ratio applique\n   IF(Stat[i]&$4000=0);'       Si l'axe n'etait pas deja esclave\n      SpBackup[i]=_SP~a;'      Mise en memoire de la vitesse de l'axe esclave\n   ENDIF\n   Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'                              MaJ bit Axe_Esclave = 1           ($4000)\n'                              MaJ bit OnOff_Autorise = 0        ($20)\n'                              MaJ bit Mvmt_Autorise = 0         ($40)\n'                              MAJ bit Positionnement_termine =0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n   JG~a=0; BG~a;'              Definition d'un Jog nul sur l'axe esclave\nELSE;IF((10<=GrAxis[i])&(GrAxis[i]<=17)&(GrAxis[i]-10<>i))\n   IF(GrAxis[i]=10);GA~a=CA;ENDIF;'   Position Commandee CA Maitre\n   IF(GrAxis[i]=11);GA~a=CB;ENDIF;'   Position Commandee CB Maitre\n   IF(GrAxis[i]=12);GA~a=CC;ENDIF;'   Position Commandee CC Maitre\n   IF(GrAxis[i]=13);GA~a=CD;ENDIF;'   Position Commandee CD Maitre\n   IF(GrAxis[i]=14);GA~a=CE;ENDIF;'   Position Commandee CE Maitre\n   IF(GrAxis[i]=15);GA~a=CF;ENDIF;'   Position Commandee CF Maitre\n   IF(GrAxis[i]=16);GA~a=CG;ENDIF;'   Position Commandee CG Maitre\n   IF(GrAxis[i]=17);GA~a=CH;ENDIF;'   Position Commandee CH Maitre\n   GR~a=GrRatio[i];'           Definition du Gear Ratio\n   GrTemp[i8]=GrAxis[i]-10;'   Memorisation des axes maitres actifs\n   GrTemp[i16]=GrRatio[i];'    Memorisation du gear ratio applique\n   IF(Stat[i]&$4000=0);'       Si l'axe n'etait pas deja esclave\n      SpBackup[i]=_SP~a;'      Mise en memoire de la vitesse de l'axe esclave\n   ENDIF\n   Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'                              MaJ bit Axe_Esclave = 1           ($4000)\n'                              MaJ bit OnOff_Autorise = 0        ($20)\n'                              MaJ bit Mvmt_Autorise = 0         ($40)\n'                              MAJ bit Positionnement_termine =0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n   JG~a=0; BG~a;'              Definition d'un Jog nul sur l'axe esclave\nELSE;IF((20<=GrAxis[i])&(GrAxis[i]<=27)&(GrAxis[i]-20<>i))\n   IF(GrAxis[i]=20);GA~a=DA;ENDIF;'   Codeur Auxiliaire DA Maitre\n   IF(GrAxis[i]=21);GA~a=DB;ENDIF;'   Codeur Auxiliaire DB Maitre\n   IF(GrAxis[i]=22);GA~a=DC;ENDIF;'   Codeur Auxiliaire DC Maitre\n   IF(GrAxis[i]=23);GA~a=DD;ENDIF;'   Codeur Auxiliaire DD Maitre\n   IF(GrAxis[i]=24);GA~a=DE;ENDIF;'   Codeur Auxiliaire DE Maitre\n   IF(GrAxis[i]=25);GA~a=DF;ENDIF;'   Codeur Auxiliaire DF Maitre\n   IF(GrAxis[i]=26);GA~a=DG;ENDIF;'   Codeur Auxiliaire DG Maitre\n   IF(GrAxis[i]=27);GA~a=DH;ENDIF;'   Codeur Auxiliaire DH Maitre\n   GR~a=GrRatio[i];'           Definition du Gear Ratio\n   GrTemp[i8]=GrAxis[i]-20;'   Memorisation des axes maitres actifs\n   GrTemp[i16]=GrRatio[i];'    Memorisation du gear ratio applique\n   IF(Stat[i]&$4000=0);'       Si l'axe n'etait pas deja esclave\n      SpBackup[i]=_SP~a;'      Mise en memoire de la vitesse de l'axe esclave\n   ENDIF\n   Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'                              MaJ bit Axe_Esclave = 1           ($4000)\n'                              MaJ bit OnOff_Autorise = 0        ($20)\n'                              MaJ bit Mvmt_Autorise = 0         ($40)\n'                              MAJ bit Positionnement_termine =0 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n   JG~a=0; BG~a;'              Definition d'un Jog nul sur l'axe esclave\nELSE\n   GR~a=0;'                    Gear Ratio Nul (Pas d'axe Maitre)\n   ST~a;'                      Arret du Jog nul de l'axe esclave\n   SP~a=SpBackup[i];'          Restauration de la vitesse de l'axe esclave\n   Stat[i]=(Stat[i]|$E0)&@COM[$4100]\n'                              MaJ bit Axe_Esclave = 0           ($4000)\n'                              MaJ bit OnOff_Autorise = 1        ($20)\n'                              MaJ bit Mvmt_Autorise = 1         ($40)\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n   GrTemp[i8]=-1;'             Memorisation: pas d'axe maitre\n   GrTemp[i16]=0;'             Memorisation: gear ratio nul\nENDIF;ENDIF;ENDIF;ENDIF\n'\n' Boucle de mise a jour du bit Axe_Maitre_Mode_Gearing\n#MAJ_GR\niGr=0;iGr8=8;'                 Index de la boucle GR (pointeur d'esclaves)\n#GRLOOP1\n   GrTemp[iGr]=0;iGr=iGr+1;iGr8=iGr8+1\nJP#GRLOOP1,iGr<nbAxes;'        Iteration suivante\n'\niGr=0;iGr8=8;'                 Index de la boucle GR (pointeur d'esclaves)\n#GRLOOP2\n   GrMaster=GrTemp[iGr8]\n   IF((0<=GrMaster)&(GrMaster<=7));' Si iGr est esclave\n      GrTemp[GrMaster]=$8000\n   ENDIF\n   iGr=iGr+1;iGr8=iGr8+1\nJP#GRLOOP2,iGr<nbAxes;'        Iteration suivante\n'\niGr=0;iGr8=8;'                 Index de la boucle GR (pointeur d'esclaves)\n#GRLOOP3\n   Stat[iGr]=(Stat[iGr]&@COM[$8000])|GrTemp[iGr]\n   iGr=iGr+1;iGr8=iGr8+1\nJP#GRLOOP3,iGr<nbAxes;'            Iteration suivante\nEN\n'\n'===== Controle du Positionnement Termine =====\n#POSCHK\nIF(PosStat[i]>1);'          Positionnement termine, debut stabilisation\n   IF(PosStat[i]=3);'          Si positionnement avec backlash,\n      PosStat[i]=2;'              Declaration: positnmt sans backlash en cours\n      PA~a=@RND[Pos[i]];BG~a;'    Positionnement\n   ELSE\n      i24=i16+8\n      StabTime[i8]=TIME+StabTime[i];'   Recup du temps fin de stabilisation\n      StabTime[i24]=TIME+StabTime[i16];'Recup du timeout de positionnement\n      PosStat[i]=1;'                    Declaration: Positnmt en stabilisation\n   ENDIF\nELSE;'                      Positionnement termine, stabilise\n   IF(StabTime[i8]<=TIME);'    Si temporisation de stabilisation ecoulee,\n      IF((@ABS[_MT~a]<>1)&(Stat[i]&$2>0));'    Si STEPPER avec CODEUR,\n         ActuPaCh=_TP~a;'         Recuperation de la position Codeur\n      ELSE\n         ActuPaCh=_PA~a;'         Recuperation de la position moteur\n      ENDIF\n      JP#POS_OK,(@ABS[Pos[i]-ActuPaCh]<=Dbw[i]);' Si position dans plage cible\n'     Si position actuelle hors de la plage cible\n      JP#POSSTOP,(_SC~a=4);'   Si dernier mouvement arrete par Stop\n      JP#POS_LS,(_SC~a=2)|(_SC~a=3);' Si dernier mouvement arrete par butee\n      i24=i16+8\n      JP#POS_OUT,(StabTime[i24]<=TIME);'Si Timeout de positionnement ecoule\n'     Attente fin de positionnement ou timeout\n   ENDIF\nENDIF\n'\nEN\n'\n'Si position dans la plage cible\n#POS_OK\n   PosStat[i]=0;'              Declaration: Pas de positionnement en cours\n   Stat[i]=((Stat[i]|$80)&@COM[$2100])\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =0 ($100)\n'                              MAJ bit Erreur_de_poursuite = 0   ($2000)\n   SP~a=SpBackup[i];'          Restauration de la vitesse\nEN\n'\n'Si position hors plage cible, gestion du Timeout\n#POS_OUT\n'  Echec de positionnement\n   PosStat[i]=0;'              Declaration: Pas de positionnement en cours\n   Stat[i]=Stat[i]|$2180;'     MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =1 ($100)\n'                              MAJ bit Erreur_de_poursuite = 1   ($2000)\n   SP~a=SpBackup[i];'          Restauration de la vitesse\nEN\n'\n'Si le dernier mouvement a ete arrete par un Stop\n#POSSTOP\n   PosStat[i]=0;'              Declaration: Pas de positionnement en cours\n   Stat[i]=Stat[i]|$80;'       MAJ bit Positionnement_termine =1 ($80)\n   SP~a=SpBackup[i];'          Restauration de la vitesse\nEN\n'\n'Si le dernier mouvement a ete arrete par une butee de fin de course\n#POS_LS\n   PosStat[i]=0;'              Declaration: Pas de positionnement en cours\n   Stat[i]=(Stat[i]|$180);'    MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =1 ($100)\n   SP~a=SpBackup[i];'          Restauration de la vitesse\nEN\n'\n'===== Controle de CpMp - Presence Codeur et Maintenance Position =====\n#CPMP\n' Si demande de desactivation du mode Remote et si telecommande active\nJS#STOPMV,(((CpMp[i]&$8)=0)&(EnRem[i]=1));'   Appel de routine d'arret\n'MAJ bits Codeur_Present ($2)\nStat[i]=(Stat[i]&@COM[$2])|(((CpMp[i]&$3)>0)*2)\n'Si pas de CODEUR, Disable Continuous Closed Loop for Stepper\nIF(Stat[i]&$2=0);CL~a=0;ENDIF\n'Si codeur absolu, alors axe automatiquement initialise (etat init des devices)\nIF((CpMp[i]&$2)>0);Stat[i]=Stat[i]|$400;ENDIF\n'MAJ bit Attributs initialises (si les bits 15 ou 31 sont a 1) ($10000)\nIF((CpMp[i]&$FFFF8000)<>0);Stat[i]=Stat[i]|$10000;ENDIF\nCpMp[i8]=CpMp[i];'             Mise en memoire de CpMp[i]\nEN\n'\n'===== Activation Continuous Closed Loop for Stepper =====\n#SETCCL\n' Si STEPPER avec CODEUR et CCL inactive,\nIF((@ABS[_MT~a]<>1)&(Stat[i]&$2>0)&(_CL~a=0))\n   DP~a=_TP~a;'                Synchronisation positions commandee et codeur\n   CL~a=1;'                    Enable Continuous Closed Loop for Stepper\nENDIF\nDB~a=Dbw[i];DS~a=@RND[Dbw[i8]*Dbw[i]];'  Accuracy appliquee dans DS et DB\nEN\n'\n'===== Controle de _CL - Continuous Closed Loop for Stepper =====\n#CCL\nStat[i]=(Stat[i]&@COM[$40000])|((_CL~a>0)*$40000)\n'                              MAJ bit Closed_loop_active($40000)\nCpMp[i16]=_CL~a;'              Mise en memoire de _CL\nEN\n'\n'===== Choix du type d'asservissement =====\n#INITASS\n'#################Configuration des Parametres CCLS ici########################\n'\n'-------------Parametres pour mode 0 ----------------\n'-----------KP---------------\nAssConf[0]=KPin;AssConf[10]=0;AssConf[20]=0;AssConf[30]=0\nAssConf[40]=0;AssConf[50]=0;AssConf[60]=0.8;AssConf[70]=0\n'-----------KI---------------\nAssConf[1]=0;AssConf[11]=0;AssConf[21]=0;AssConf[31]=0\nAssConf[41]=0;AssConf[51]=0;AssConf[61]=0;AssConf[71]=0\n'-----------KD---------------\nAssConf[2]=0;AssConf[12]=0;AssConf[22]=0;AssConf[32]=0\nAssConf[42]=0;AssConf[52]=0;AssConf[62]=0;AssConf[72]=0\n'-----------K1---------------\nAssConf[3]=0;AssConf[13]=0;AssConf[23]=0;AssConf[33]=0\nAssConf[43]=0;AssConf[53]=0;AssConf[63]=0.8;AssConf[73]=0\n'-----------K2---------------\nAssConf[4]=0;AssConf[14]=0;AssConf[24]=0;AssConf[34]=0\nAssConf[44]=0;AssConf[54]=0;AssConf[64]=0;AssConf[74]=0\n'-----------K3---------------\nAssConf[5]=0;AssConf[15]=0;AssConf[25]=0;AssConf[35]=0\nAssConf[45]=0;AssConf[55]=0;AssConf[65]=0;AssConf[75]=0\n'-----------FV---------------\nAssConf[6]=0;AssConf[16]=0;AssConf[26]=0;AssConf[36]=0\nAssConf[46]=0;AssConf[56]=0;AssConf[66]=0;AssConf[76]=0\n'-----------ER---------------\nAssConf[7]=0;AssConf[17]=0;AssConf[27]=0;AssConf[37]=0\nAssConf[47]=0;AssConf[57]=0;AssConf[67]=1000;AssConf[77]=0\n'-----------ZP---------------\nAssConf[8]=0;AssConf[18]=0;AssConf[28]=0;AssConf[38]=0\nAssConf[48]=0;AssConf[58]=0;AssConf[68]=0.0003;AssConf[78]=0\n'-----------ZN---------------\nAssConf[9]=0;AssConf[19]=0;AssConf[29]=0;AssConf[39]=0\nAssConf[49]=0;AssConf[59]=0;AssConf[69]=0.0006;AssConf[79]=0\n'\n'-------------Parametres pour mode 1 ----------------\n'-----------KP---------------\nAssConf[80]=0;AssConf[90]=0;AssConf[100]=0;AssConf[110]=0\nAssConf[120]=4;AssConf[130]=0;AssConf[140]=0.8;AssConf[150]=0\n'-----------KI---------------\nAssConf[81]=0;AssConf[91]=0;AssConf[101]=0;AssConf[111]=0\nAssConf[121]=0;AssConf[131]=0;AssConf[141]=0;AssConf[151]=0\n'-----------KD---------------\nAssConf[82]=0;AssConf[92]=0;AssConf[102]=0;AssConf[112]=0\nAssConf[122]=0;AssConf[132]=0;AssConf[142]=0;AssConf[152]=0\n'-----------K1---------------\nAssConf[83]=0;AssConf[93]=0;AssConf[103]=0;AssConf[113]=0\nAssConf[123]=4;AssConf[133]=0;AssConf[143]=0.8;AssConf[153]=0\n'-----------K2---------------\nAssConf[84]=0;AssConf[94]=0;AssConf[104]=0;AssConf[114]=0\nAssConf[124]=0;AssConf[134]=0;AssConf[144]=0;AssConf[154]=0\n'-----------K3---------------\nAssConf[85]=0;AssConf[95]=0;AssConf[105]=0;AssConf[115]=0\nAssConf[125]=0;AssConf[135]=0;AssConf[145]=0;AssConf[155]=0\n'-----------FV---------------\nAssConf[86]=0;AssConf[96]=40;AssConf[106]=0;AssConf[116]=0\nAssConf[126]=10;AssConf[136]=0;AssConf[146]=0;AssConf[156]=0\n'-----------ER---------------\nAssConf[87]=0;AssConf[97]=0;AssConf[107]=0;AssConf[117]=0\nAssConf[127]=0;AssConf[137]=0;AssConf[147]=1100;AssConf[157]=0\n'-----------ZP---------------\nAssConf[88]=0;AssConf[98]=0;AssConf[108]=0;AssConf[118]=0\nAssConf[128]=0;AssConf[138]=0;AssConf[148]=0.0009;AssConf[158]=0\n'-----------ZN---------------\nAssConf[89]=0;AssConf[99]=0;AssConf[109]=0;AssConf[119]=0\nAssConf[129]=0;AssConf[139]=0;AssConf[149]=0.0012;AssConf[159]=0\n'\n'-------------Parametres pour mode 2 ----------------\n'-----------KP---------------\nAssConf[160]=0;AssConf[170]=0;AssConf[180]=0;AssConf[190]=0\nAssConf[200]=0;AssConf[210]=0;AssConf[220]=0.8;AssConf[230]=0\n'-----------KI---------------\nAssConf[161]=0;AssConf[171]=0;AssConf[181]=0;AssConf[191]=0\nAssConf[201]=0;AssConf[211]=0;AssConf[221]=0;AssConf[231]=0\n'-----------KD---------------\nAssConf[162]=0;AssConf[172]=0;AssConf[182]=0;AssConf[192]=0\nAssConf[202]=0;AssConf[212]=0;AssConf[222]=0;AssConf[232]=0\n'-----------K1---------------\nAssConf[163]=0;AssConf[173]=0;AssConf[183]=0;AssConf[193]=0\nAssConf[203]=0;AssConf[213]=0;AssConf[223]=0.8;AssConf[233]=0\n'-----------K2---------------\nAssConf[164]=0;AssConf[174]=0;AssConf[184]=0;AssConf[194]=0\nAssConf[204]=0;AssConf[214]=0;AssConf[224]=0;AssConf[234]=0\n'-----------K3---------------\nAssConf[165]=0;AssConf[175]=0;AssConf[185]=0;AssConf[195]=0\nAssConf[205]=0;AssConf[215]=0;AssConf[225]=0;AssConf[235]=0\n'-----------FV---------------\nAssConf[166]=0;AssConf[176]=0;AssConf[186]=0;AssConf[196]=0\nAssConf[206]=0;AssConf[216]=0;AssConf[226]=0;AssConf[236]=0\n'-----------ER---------------\nAssConf[167]=0;AssConf[177]=0;AssConf[187]=0;AssConf[197]=0\nAssConf[207]=0;AssConf[217]=0;AssConf[227]=1200;AssConf[237]=0\n'-----------ZP---------------\nAssConf[168]=0;AssConf[178]=0;AssConf[188]=0;AssConf[198]=0\nAssConf[208]=0;AssConf[218]=0;AssConf[228]=0.0015;AssConf[238]=0\n'-----------ZN---------------\nAssConf[169]=0;AssConf[179]=0;AssConf[189]=0;AssConf[199]=0\nAssConf[209]=0;AssConf[219]=0;AssConf[229]=0.0018;AssConf[239]=0\n'\n'-------------Parametres pour mode 3 ----------------\n'-----------KP---------------\nAssConf[240]=0;AssConf[250]=0;AssConf[260]=0;AssConf[270]=0\nAssConf[280]=0;AssConf[290]=0;AssConf[300]=0.8;AssConf[310]=0\n'-----------KI---------------\nAssConf[241]=0;AssConf[251]=0;AssConf[261]=0;AssConf[271]=0\nAssConf[281]=0;AssConf[291]=0;AssConf[301]=0;AssConf[311]=0\n'-----------KD---------------\nAssConf[242]=0;AssConf[252]=0;AssConf[262]=0;AssConf[272]=0\nAssConf[282]=0;AssConf[292]=0;AssConf[302]=0;AssConf[312]=0\n'-----------K1---------------\nAssConf[243]=0;AssConf[253]=0;AssConf[263]=0;AssConf[273]=0\nAssConf[283]=0;AssConf[293]=0;AssConf[303]=0.8;AssConf[313]=0\n'-----------K2---------------\nAssConf[244]=0;AssConf[254]=0;AssConf[264]=0;AssConf[274]=0\nAssConf[284]=0;AssConf[294]=0;AssConf[304]=0;AssConf[314]=0\n'-----------K3---------------\nAssConf[245]=0;AssConf[255]=0;AssConf[265]=0;AssConf[275]=0\nAssConf[285]=0;AssConf[295]=0;AssConf[305]=0;AssConf[315]=0\n'-----------FV---------------\nAssConf[246]=;AssConf[256]=40;AssConf[266]=0;AssConf[276]=0\nAssConf[286]=0;AssConf[296]=0;AssConf[306]=0;AssConf[316]=0\n'-----------ER--------------\nAssConf[247]=0;AssConf[257]=0;AssConf[267]=0;AssConf[277]=0\nAssConf[287]=0;AssConf[297]=0;AssConf[307]=1300;AssConf[317]=0\n'-----------ZP---------------\nAssConf[248]=0;AssConf[258]=0;AssConf[268]=0;AssConf[278]=0\nAssConf[288]=0;AssConf[298]=0;AssConf[308]=0.0021;AssConf[318]=0\n'-----------ZN---------------\nAssConf[249]=0;AssConf[259]=0;AssConf[269]=0;AssConf[279]=0\nAssConf[289]=0;AssConf[299]=0;AssConf[309]=0.0024;AssConf[319]=0\n' ---------------------------------\n' Selection du mode d asservissement par defaut\nModAss[0]=1;ModAss[1]=1;ModAss[2]=1;ModAss[3]=1\nModAss[4]=1;ModAss[5]=1;ModAss[6]=2;ModAss[7]=1\nEN\n'###############################################################\n'\n#SETASS\n' Si le mode d asservissement est 0\nIF((ModAss[i]=0)&((Stat[i]&$80)<>0))\n ' L'adresse initiale est 0\n ValInc=0;TempAx=0;JS#ADRCONF;JS#SETCONF\n ' Si le mode d asservissement est 1\nELSE;IF((ModAss[i]=1)&((Stat[i]&$80)<>0))\n ' L'adresse initiale est 80\n ValInc=80;TempAx=0;JS#ADRCONF;JS#SETCONF\n ' Si le mode d asservissement est 2\nELSE;IF((ModAss[i]=2)&((Stat[i]&$80)<>0))\n ' L'adresse initiale est 160\n ValInc=160;TempAx=0;JS#ADRCONF;JS#SETCONF\n ' Si le mode d asservissement est 3\nELSE;IF((ModAss[i]=3)&((Stat[i]&$80)<>0))\n ' L'adresse initiale est 240\n ValInc=240;TempAx=0;JS#ADRCONF;JS#SETCONF\n ' Sinon retablissement de la commande precedente\nELSE\n ModAss[i]=AssBckup[i]\nENDIF;ENDIF;ENDIF;ENDIF\nAssBckup[i]=ModAss[i];' mise en memoire du mode choisi\nValInc=0;TempAx=0;' RaZ des variables d'adressage\nEN\n'\n#ADRCONF\n'Si l'axe est different du A, on decale le pointeur d'adresse a l'axe suivant\nIF (i<>0);ValInc=ValInc+10;ENDIF\n'Verification de l'axe suivant\n TempAx=TempAx+1\n JP #ADRCONF,(TempAx<i)\n' jusqu'a avoir trouve l'axe modifie\nEN\n'\n#SETCONF\n'   Mise a jour des parametres d asservissement statiques\n KP~a=AssConf[ValInc];ValInc=ValInc+1;KI~a=AssConf[ValInc]\n ValInc=ValInc+1;KD~a=AssConf[ValInc];ValInc=ValInc+1\n'   Mise a jour des parametres d asservissement dynamiques\n K1~a=AssConf[ValInc];ValInc=ValInc+1;K2~a=AssConf[ValInc]\nValInc=ValInc+1;K3~a=AssConf[ValInc];ValInc=ValInc+1\n'   Mise a jour des parametres d environnement\n FV~a=AssConf[ValInc];ValInc=ValInc+1;ER~a=AssConf[ValInc]\nValInc=ValInc+1\nZP~a=AssConf[ValInc];ValInc=ValInc+1;ZN~a=AssConf[ValInc]\n'\nEN\n'\n'===== Routine Remote - Pilotage des motorisations avec une telecommande =====\n#REMOTE\nIF(i>3); iRem=i+5; ELSE; iRem=i+1; ENDIF;'Decalage de l'index des INPUTS\n'\nIF(@IN[iRem]=1);'      Si l'entree iRem est a 1, telecommande innactive\n   JS#STOPMV,(EnRem[i8]=1);'      Appel de routine d'arret si axe en mouvement\nELSE;'         Si l'entree iRem est a 0, telecommande active\n   Stat[i]=(Stat[i]|$8)&@COM[$1E0];' MaJ bit Telecommande Active = 1   ($8)\n'                                    MaJ bit OnOff_Autorise = 0        ($20)\n'                                    MaJ bit Mvmt_Autorise = 0         ($40)\n'                                    MaJ bit Positionnement_termine =0 ($80)\n'                                    MaJ bit Pos_termine_sur_erreur =0 ($100)\n   IF(EnRem[i8]=0);'   Si l'axe est a l'arret\n      JS#STARTMV;'     Appel de la routine de demarrage de l'axe\n   ELSE;'              Si l'axe est en mouvement\n      JS#MOVE;'        Appel de la routine de MaJ de la vitesse de l'axe\n   ENDIF\nENDIF\nOB(2*i+1),(_LR~a=0)|(_LF~a=0);'   Affichage de l'etat des fins de course\nEN\n' ***** Start Move *****\n#STARTMV\nST~a;'                 Arret de l'axe\nSpBackup[i8]=0;'       Mode JOG off\nPosStat[i]=0;'         Pas de positionnement en cours\nIF(_MO~a);SH~a;ENDIF;' Demarrage de l'axe s'il ne l'est pas\nJS#SETCCL;'            Activation CCL des Stepper avec Codeur\nSpBackup[i16]=_SP~a;'  Recuperation de la valeur de la vitesse\nJG~a=0; BG~a;'         Initialisation d'un mouvement a vitesse nulle\nEnRem[i8]=1;'          Declaration de l'etat de l'axe : Ready\nSB(2*i+2);'            Led Ready : axe ON\nEN\n' ******** Move ********\n#MOVE\nana=@AN[i+1];'         Memorisation de l'entree Analogique de l'axe i+1\n'Lancement du Jog en fonction de la consigne analogique\nJP#NEG_LOW,((ana>2)&(ana<3.5));'      Vitesse Lente,  sens Negatif\nJP#NEG_HIG,((ana>4)&(ana<5.5));'      Vitesse Rapide, sens Negatif\nJP#POS_LOW,((ana>6)&(ana<7.5));'      Vitesse Lente,  sens Positif\nJP#POS_HIG,((ana>8)&(ana<9.7));'      Vitesse Rapide, sens Positif\nJG~a=0;'               Vitesse nulle\n'Redemarrage de l'axe s'il est arrete et si l'etat des butees le permet\nIF((_TS~a&$A8)=$8);BG~a;ENDIF\nEN\n'Vitesse Lente, sens Negatif\n#NEG_LOW\nJG~a=-SpBackup[i16]/5\nIF((_TS~a&$A4)=$4);BG~a;ENDIF\nEN\n'Vitesse Rapide, sens Negatif\n#NEG_HIG\nJG~a=-SpBackup[i16]\nIF((_TS~a&$A4)=$4);BG~a;ENDIF\nEN\n'Vitesse Lente, sens Positif\n#POS_LOW\nJG~a=SpBackup[i16]/5\nIF((_TS~a&$A8)=$8);BG~a;ENDIF\nEN\n'Vitesse Rapide, sens Positif\n#POS_HIG\nJG~a=SpBackup[i16]\nIF((_TS~a&$A8)=$8);BG~a;ENDIF\nEN\n' ****** Stop Move *****\n#STOPMV\nST~a;'                 Arret de l'axe\nIF(EnRem[i8]);'        Si telecommande active,\n   SP~a=SpBackup[i16];'Restauration de la valeur de la vitesse\nENDIF\nEnRem[i8]=0;'          Declaration de l'etat de l'axe : OFF\nCB(2*i+2);'            Led Ready : axe OFF\nStat[i]=(Stat[i]|$E0)&@COM[$108];'   MaJ bit Telecommande Active = 0   ($8)\n'                                    MaJ bit OnOff_Autorise = 1        ($20)\n'                                    MaJ bit Mvmt_Autorise = 1         ($40)\n'                                    MaJ bit Positionnement_termine =1 ($80)\n'                                    MaJ bit Pos_termine_sur_erreur =0 ($100)\nEN\n'\n'======= Routine de traitement des Fins de courses =======\n#LIMSWI\niLS=0;iLS8=8;iLS16=16;~d=0;'   Initialisation pointeur de tableau et d'axe\n'\n' Boucle de detection des axes iLS en Butee\n#LSLOOP\n   JP#LS_NEXT,(((_SC~d=2)|(_SC~d=3))=0);'Si butee inactive, suivante\n   JS#LSDEBUG,(Debug=1);'            DEBUG\n   JP#LSINPOM,(Stat[iLS]&$200>0);'   Si Prise d'Origine en cours\n   JP#LS_STD;'                       Traitement des butees classiques\n'\n#LS_NEXT\n'  Increment des pointeurs de tableau et d'axe\n   iLS=iLS+1;iLS8=iLS8+1;iLS16=iLS16+1;~d=iLS\nJP#LSLOOP,(iLS<nbAxes);'   Controle des 8 axes\n'\nRE0;'                  Retour d'interruption #LIMSWI\n'\n' Traitement des butees classiques\n#LS_STD\n   DcLimBck=_DC~d;'    Mise en memoire de la deceleration\n   ST~d;'              Arret de l'axe\n   IF(_DC~d<DcLimSwi);DC~d=DcLimSwi;ENDIF;'   Augmentation des DC trop lentes\n   IF(GrTemp[iLS8]>=0);'       Si l'axe iLS est esclave,\n      valTildD=~d;'            Mise en memoire de l'axe pointe par ~d\n      IF(GrTemp[iLS8]=8);'     Si N est l'axe maitre (axe virtuel),\n         ~d=10;'               pointeur de l'axe virtuel\n      ELSE\n         lsMaster=(GrTemp[iLS8]&$0F);' recherche du maitre de l'axe iLS\n         lsMaste8=lsMaster+8\n         ~d=lsMaster;'         pointeur de l'axe maitre\n         SpBackup[lsMaste8]=0;'Mode JOG off\n         PosStat[lsMaster]=0;' Pas de positionnement en cours\n         Stat[lsMaster]=(Stat[lsMaster]|$180)\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MaJ bit Pos_termine_sur_erreur =1 ($100)\n      ENDIF\n      ST~d;'                   Arret de l'axe maitre\n      ~d=valTildD;'            Restauration de l'axe pointe par ~d\n'      Arret de la synchronisation maitre-esclave et MAJ des bits\n      GR~d=0;'                 Gear Ratio Nul (Pas d'axe Maitre)\n      ST~d;'                   Arret du Jog nul de l'axe esclave\n      SP~d=SpBackup[iLS];'     Restauration de la vitesse de l'axe esclave\n      Stat[iLS]=(Stat[iLS]|$1E0)&@COM[$4000]\n'                              MaJ bit Axe_Esclave = 0           ($4000)\n'                              MaJ bit OnOff_Autorise = 1        ($20)\n'                              MaJ bit Mvmt_Autorise = 1         ($40)\n'                              MaJ bit Positionnement_termine =1 ($80)\n'                              MaJ bit Pos_termine_sur_erreur =1 ($100)\n      GrTemp[iLS8]=-1;'        Memorisation: pas d'axe maitre\n      GrTemp[iLS16]=0;'        Memorisation: gear ratio nul\n      JS#MAJ_GR;'              MaJ des bits de Gearing\n   ENDIF\n   Stat[iLS]=Stat[iLS]|$180;'  MaJ bit Positionnement_termine =1 ($80)\n'                              MaJ bit Pos_termine_sur_erreur =1 ($100)\n   SpBackup[iLS8]=0;'          Mode JOG off\n   PosStat[iLS]=0;'            Pas de positionnement en cours\nIF(CmdHvOk);'                  Si la commande HV est supportee,\n DC~d=DcOld[iLS];'             Set deceleration to old value\n ELSE\n DC~d=DcLimBck;'               Restauration de la deceleration\nENDIF\n'\n'IF((Stat[iLS]&$40000)<>0);'    Si la CCLS est active\n' WT (StabTime[iLS]/2);'        attente de stabilisation de l'axe\n' DP~d=_TP~d;'                  Synchronisation positions commandee et codeur\n'ENDIF\nJP#LS_NEXT\nEN\n'\n' Traitement des butees actives en cours de prise d'origine\n#LSINPOM\n  IF(PosStat[iLS8]=0);'        Si prise d'origine sur home ou index\n    DcLimBck=_DC~d;'           Mise en memoire de la deceleration\n    DcOld[iLS]=_DC~a;'         Storing current values of deceleration\n    IF(_DC~d<DcLimSwi);DC~d=DcLimSwi;ENDIF;' Augmentation des DC trop lentes\n    HX1;'                      Arret de la tache de POM sur erreur\n    ST~d;'                     Arret de l'axe\n    Stat[iLS]=((Stat[iLS]&@COM[$606])|$980)|(((CpMp[iLS]&3)>0)*2)|(CpMp[iLS]&4)\n'                              MAJ bit Codeur_Present            ($2)\n'                              MAJ bit Maintenance_Position      ($4)\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =1 ($100)\n'                              MAJ bit Prise_Ref_en_cours= 0     ($200)\n'                              MAJ bit Prise_Ref_Faite = 0       ($400)\n'                              MAJ bit Echec_Prise_Ref = 1       ($800)\n    CpMp[iLS8]=CpMp[iLS];'     Mise en memoire de CpMp[iLS]\n    iFh=nbFh;iFi=nbFi;'        Arret des recherches de home et d'index\n    SpBackup[iLS8]=0;'         Mode JOG off\n    PosStat[iLS]=0;'           Pas de positionnement en cours\nIF(CmdHvOk);'               Si la commande HV est supportee,\n DC~d=DcOld[iLS];'             Set deceleration to old value\n ELSE\n DC~d=DcLimBck;'               Restauration de la deceleration\nENDIF\n    SP~d=PomSpBck;'            Restauration de la vitesse avant prise d'origine\n  ENDIF;'                      Pas d'erreur si prise d'origine sur butee + ou -\nJP#LS_NEXT\nEN\n'\n#LSDEBUG\nCFS;MG"LimSw Axis",~d," LineT0",_XQ0," LineT1",_XQ1;'!! DEBUG !!\nEN\n'=========================================================\n'\n'========== Gestion_des_commandes_erronnees ==========\n#CMDERR\n'\nIF(Debug=1)\n CFS;MG"CMD Error",_TC," Line",_ED2," Thread",_ED1;'!! SEULEMENT POUR DEBUG !!\nENDIF\n'\nJP#CMDTR0,(_ED1=0);'   Si le thread 0 est en erreur\nJP#CMDTR1,(_ED1=1);'   Si le thread 1 "Prise d'origine" est en erreur\nJP#CMDTRN;'            Si un autre thread est en erreur\nEN\n'\n#CMDTR0\nIF(_TC=TstCmdEr);'   SI "Variable_error" (9) ou "Bad command response" (58)\n   TC\n   IF(_XQ_ED1<0);'   Si le thread de l'erreur n'est plus execute\n      ZS1\n      XQ_ED3,_ED1,1;'   Execute commande suivante dans le thread de l'erreur\n   ENDIF\nENDIF\n'\nIF((_TC=20)|(_TC=21)|(_TC=22));'SI "Begin_not_valid_with_motor_off" (20)\n'                               OU "Begin_not_valid_while_running" (21)\n'                               OU "Begin_not_possible_due_to_Lim_Switch" (22)\n   IF(((_LR~a&_LF~a)=0)|(_MO~a));'Si une butee est active ou le moteur est Off\n      Stat[i]=(Stat[i]|$180);'  MAJ bit Positionnement_termine =1 ($80)\n'                               MAJ bit Pos_termine_sur_erreur =1 ($100)\n      PosStat[i]=0;'            Pas de positionnement en cours\n      IF(GrTemp[i8]>=0);'       Si l'axe i est esclave, arret du maitre\n         valTildA=~a;'          Mise en memoire de l'axe pointe par ~a\n         IF(GrTemp[i8]=8);'     Si N est l'axe maitre (axe virtuel),\n            ~a=10;'             pointeur de l'axe virtuel\n         ELSE\n            erMaster=(GrTemp[i8]&$0F);'   recherche du maitre de l'axe i\n            erMaste8=erMaster+8\n            ~a=erMaster;'            pointeur de l'axe maitre\n            SpBackup[erMaste8]=0;'   Mode JOG off\n            PosStat[erMaster]=0;'    Pas de positionnement en cours\n            Stat[erMaster]=(Stat[erMaster]|$180);'MAJ Positnmnt_termine=1 ($80)\n'                                    MAJ Pos_termine_sur_erreur=1   ($100)\n         ENDIF\n         ST~a;'                 Arret de l'axe maitre\n         ~a=valTildA;'          Restauration de l'axe pointe par ~a (esclave)\n'         Arret de la synchronisation maitre-esclave et MAJ des bits\n         GR~a=0;'               Gear Ratio Nul (Pas d'axe Maitre)\n         ST~a;'                 Arret du Jog nul de l'axe esclave\n         SP~a=SpBackup[i];'     Restauration de la vitesse de l'axe esclave\n         Stat[i]=(Stat[i]|$1E0)&@COM[$4000]\n'                               MAJ bit Axe_Esclave = 0            ($4000)\n'                               MAJ bit OnOff_Autorise = 1         ($20)\n'                               MAJ bit Mvmt_Autorise = 1          ($40)\n'                               MAJ bit Positionnement_termine =1  ($80)\n'                               MAJ bit Pos_termine_sur_erreur =1  ($100)\n         GrTemp[i8]=-1;'        Memorisation: pas d'axe maitre\n         GrTemp[i16]=0;'        Memorisation: gear ratio nul\n         JS#MAJ_GR;'            MAJ des bits de Gearing\n      ENDIF\n   ENDIF\n   IF(_XQ_ED1<0);'   Si le thread de l'erreur n'est plus execute\n      XQ_ED3,_ED1,1;'   Execute commande suivante dans le thread de l'erreur\n   ENDIF\nENDIF\nEN\n'\n#CMDTR1\nStat[iPom]=((Stat[iPom]&@COM[$606])|$880)|(((CpMp[iPom]&3)>0)*2)|(CpMp[iPom]&4)\n'               MAJ bit Codeur_Present            ($2)\n'               MAJ bit Maintenance_Position      ($4)\n'               MAJ bit Positionnement_termine =1 ($80)\n'               MAJ bit Prise_Ref_en_cours= 0     ($200)\n'               MAJ bit Prise_Ref_Faite = 0       ($400)\n'               MAJ bit Echec_Prise_Ref = 1       ($800)\nCpMp[iPom8]=CpMp[iPom];' Mise en memoire de CpMp[iPom]\nST~b;'                   Arret de l'axe\nSpBackup[iPom8]=0;'      Mode JOG off\nPosStat[iPom]=0;'        Pas de positionnement en cours\nPosStat[iPom8]=0;'       Pas de Prise d'origine sur butee en cours\nSP~b=PomSpBck;'          Restauration de la vitesse avant prise d'origine\nEN\n'\n#CMDTRN\nIF((_TC=20)|(_TC=21)|(_TC=22));' SI "Begin_not_valid_with_motor_off" (20)\n'                                OU "Begin_not_valid_while_running" (21)\n'                                OU "Begin_not_possible_due_to_Lim_Switch" (22)\n'  Si une butee est active ou le moteur est Off\n'  MAJ bit Positionnement_termine=1   ($80)\n'  MAJ bit Pos_termine_sur_erreur=1   ($100)\n'  et declaration : pas de positionnement en cours\n  IF((LastAxis=0)&((_LRA&_LFA=0)|_MOA));Stat[0]=Stat[0]|$180;PosStat[0]=0;ENDIF\n  IF((LastAxis=1)&((_LRB&_LFB=0)|_MOB));Stat[1]=Stat[1]|$180;PosStat[1]=0;ENDIF\n  IF((LastAxis=2)&((_LRC&_LFC=0)|_MOC));Stat[2]=Stat[2]|$180;PosStat[2]=0;ENDIF\n  IF((LastAxis=3)&((_LRD&_LFD=0)|_MOD));Stat[3]=Stat[3]|$180;PosStat[3]=0;ENDIF\n  IF((LastAxis=4)&((_LRE&_LFE=0)|_MOE));Stat[4]=Stat[4]|$180;PosStat[4]=0;ENDIF\n  IF((LastAxis=5)&((_LRF&_LFF=0)|_MOF));Stat[5]=Stat[5]|$180;PosStat[5]=0;ENDIF\n  IF((LastAxis=6)&((_LRG&_LFG=0)|_MOG));Stat[6]=Stat[6]|$180;PosStat[6]=0;ENDIF\n  IF((LastAxis=7)&((_LRH&_LFH=0)|_MOH));Stat[7]=Stat[7]|$180;PosStat[7]=0;ENDIF\n'\n  XQ_ED3,_ED1,1;'   Execute commande suivante dans le thread de l'erreur\nENDIF\nEN\n'\n'===== Routine de traitement des erreurs de position =====\n#POSERR\niPE=0;iPE8=8;iPE16=16;~c=0;'      Initialisation pointeurs de tableau et d'axe\n'\n' Boucle de detection des axes iPE en Erreur de Position\n#PELOOP\n'\nIF(_TS~c&64>0);'   Si l'axe ~c est en erreur de position,\n'\n   IF(Stat[iPE]&$200>0);'   Si Prise d'Origine en cours,\n      HX1;'                    Arret de la tache de POM sur erreur\n   Stat[iPE]=((Stat[iPE]&@COM[$606])|$2980)|(((CpMp[iPE]&3)>0)*2)|(CpMp[iPE]&4)\n'                              MAJ bit Codeur_Present            ($2)\n'                              MAJ bit Maintenance_Position      ($4)\n'                              MAJ bit Positionnement_termine =1 ($80)\n'                              MAJ bit Pos_termine_sur_erreur =1 ($100)\n'                              MAJ bit Prise_Ref_en_cours= 0     ($200)\n'                              MAJ bit Prise_Ref_Faite = 0       ($400)\n'                              MAJ bit Echec_Prise_Ref = 1       ($800)\n'                              MAJ bit Erreur_de_poursuite = 1   ($2000)\n      CpMp[iPE8]=CpMp[iPE];'   Mise en memoire de CpMp[iPE]\n      CL~c=0;'                 Ouverture de la boucle CCLS\n       ST~c;'                   Arret de l'axe\n      SpBackup[iPE8]=0;'       Mode JOG off\n      PosStat[iPE]=0;'         Pas de positionnement en cours\n      PosStat[iPE8]=0;'        Pas de Prise d'origine sur butee en cours\n      SP~c=PomSpBck;'          Restauration de la vitesse avant prise d'origine\n'\n   ELSE;'            Si pas de Prise d'Origine en cours,\n      PosStat[iPE]=0;'         Declaration: pas de positionnement en cours\n      IF(GrTemp[iPE8]>=0);' Si l'axe iPE est esclave, arret du maitre\n         valTildC=~c;'      Mise en memoire de l'axe pointe par ~c\n         IF(GrTemp[iPE8]=8);'      Si N est l'axe maitre (axe virtuel),\n            ~c=10;'                pointeur de l'axe virtuel\n         ELSE\n            PeMaster=(GrTemp[iPE8]&$0F);' recherche du maitre de l'axe iPE\n            PeMaste8=PeMaster+8\n            ~c=PeMaster;'          pointeur de l'axe maitre\n            SpBackup[PeMaste8]=0;' Mode JOG off\n            PosStat[PeMaster]=0;'  Pas de positionnement en cours\n            Stat[PeMaster]=(Stat[PeMaster]|$180);'MAJ bit Pos_termine=1($80)\n'                                  MAJ bit Pos_termine_sur_erreur=1   ($100)\n         ENDIF\n         ST~c;'             Arret de l'axe maitre\n         ~c=valTildC;'      Restauration de l'axe pointe par ~c\n'        Arret de la synchronisation maitre-esclave et MAJ des bits\n         GR~c=0;'           Gear Ratio Nul (Pas d'axe Maitre)\n         ST~c;'             Arret du Jog nul de l'axe esclave\n         SP~c=SpBackup[iPE];' Restauration de la vitesse de l'axe esclave\n         Stat[iPE]=(Stat[iPE]|$1E0)&@COM[$4000]\n'                           MaJ bit Axe_Esclave = 0           ($4000)\n'                           MaJ bit OnOff_Autorise = 1        ($20)\n'                           MaJ bit Mvmt_Autorise = 1         ($40)\n'                           MAJ bit Positionnement_termine =1 ($80)\n'                           MAJ bit Pos_termine_sur_erreur =1 ($100)\n         GrTemp[iPE8]=-1;'  Memorisation: pas d'axe maitre\n         GrTemp[iPE16]=0;'  Memorisation: gear ratio nul\n         JS#MAJ_GR;'        MAJ des bits de Gearing\n      ENDIF\n      CL~c=0;'           Ouverture de la boucle CCLS\n      Stat[iPE]=Stat[iPE]|$2180;' MAJ bit Positionnement_termine =1 ($80)\n'                                 MAJ bit Pos_termine_sur_erreur =1 ($100)\n'                                 MAJ bit Erreur_de_poursuite = 1   ($2000)\n   ENDIF\n'  Si SERVO en erreur de position, etat Off et vitesse reduite,\n   IF((@ABS[_MT~c]=1)&(@ABS[_TE~c]>=_ER~c)&(_MO~c)&(@ABS[_TV~c]<100))\n      DP~c=_TP~c;'  Definition position commandee selon codeur (RAZ erreur)\n      Stat[iPE]=Stat[iPE]|$2000;'    MAJ bit Erreur_de_poursuite =1  ($2000)\n   ENDIF\nENDIF\n'Increment pointeur de tableau et pointeur d'axe\niPE=iPE+1;iPE8=iPE8+1;iPE16=iPE16+1;~c=iPE\nJP#PELOOP,(iPE<nbAxes);'       Controle des 8 axes\nRE0;'                          Retour d'interruption #POSERR\n'\n'######################### FIN DU MICROCODE GENERIQUE #########################\n'\n'===== Routine d'initialisation et declaration des variables specifiques =====\n#INITSPE;'   !!! ne pas supprimer !!!\n'declaration des tableaux du microcode specifique\n' ...\n'initialisation des variables et des tableaux specifiques\n' ...\n   LastAxis=-1;' Pointeur du dernier axe sur lequel un mouvement a ete commande\n'\n'Les tableaux sont indexes pas la variable iSPE (comprise entre 0 et 7)\n'-ici le microcode specifique peut etre declare comme etant actif :\n'   sur l'axe iSPE :   Stat[iSPE]=(Stat[iSPE]|$10)\n'-ici peut etre interdit le MotorOn/Off au device :\n'   pour l'axe iSPE :  Stat[iSPE]=(Stat[iSPE]&@COM[$20])\n'-ici peuvent etre interdits les mouvements au device :\n'   pour l'axe iSPE :  Stat[iSPE]=(Stat[iSPE]&@COM[$40])\n'-ici peut etre desactive le mode remote pour l'axe iSPE condidere :\n'   EnRem[iSPE]=0;'   Mote remote interdit par le Microcode\n'-ici peut figurer une commande d'execution d'une tache specifique du type :\n'   XQ#SPE_TSK,7\n'\nEN;'      !!! ne pas supprimer !!!\n'\n'================= Tache Specifique executee par #INITSPE ===================\n'#SPE_TSK\n' ...\n'EN\n'\n'=== Routine Specifique appelee sequentiellement par la boucle principale ===\n'#SPE_SEQ\n' ...\n'EN"
