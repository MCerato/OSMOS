[SystemInfo]
Firmware=DMC4183s56g
Serial=15953.0000
Device=DMC41x3
Axis=8

[Configuration]
EO=false
VF=VF 10.4\r
PF=PF 10.0\r
LZ=LZ 1\r
MT\size=8
MT\1\Cmd="MTA=2.0\r"
MT\2\Cmd="MTB=2.0\r"
MT\3\Cmd="MTC=2.0\r"
MT\4\Cmd="MTD=2.0\r"
MT\5\Cmd="MTE=2.0\r"
MT\6\Cmd="MTF=2.0\r"
MT\7\Cmd="MTG=2.0\r"
MT\8\Cmd="MTH=2.0\r"
GA\size=2
GA\1\Cmd="GAA=CB\r"
GA\2\Cmd="GAC=CD\r"
BA\size=1
BA\1\Cmd=BA N\r
CE="CEA=4\rCEB=4\rCEC=4\rCED=4\rCEE=4\rCEF=4\rCEG=4\rCEH=6\r"
AF="AFA=0\rAFB=0\rAFC=0\rAFD=0\rAFE=0\rAFF=0\rAFG=0\rAFH=0\r"
DV="DVA=0\rDVB=0\rDVC=0\rDVD=0\rDVE=0\rDVF=0\rDVG=0\rDVH=0\r"
BR="BRA=0\rBRB=0\rBRC=0\rBRD=0\rBRE=0\rBRF=0\rBRG=0\rBRH=0\r"
FL="FLA=2147483647\rFLB=2147483647\rFLC=2147483647\rFLD=2147483647\rFLE=2147483647\rFLF=2147483647\rFLG=2147483647\rFLH=2147483647\r"
BL="BLA=-2147483648\rBLB=-2147483648\rBLC=-2147483648\rBLD=-2147483648\rBLE=-2147483648\rBLF=-2147483648\rBLG=-2147483648\rBLH=-2147483648\r"
CL="CLA=0\rCLB=0\rCLC=0\rCLD=0\rCLE=0\rCLF=0\rCLG=0\rCLH=0\r"
SI="SIA=0,25,12,5<0>0\rSIB=0,0,0,0<0>0\rSIC=0,0,0,0<0>0\rSID=0,0,0,0<0>0\rSIE=0,0,0,0<0>0\rSIF=0,0,0,0<0>0\rSIG=0,0,0,0<0>0\rSIH=0,0,0,0<0>0\r"
SS="SSA=0,0,0,0<0\rSSB=0,0,0,0<0\rSSC=0,0,0,0<0\rSSD=0,0,0,0<0\rSSE=0,0,0,0<0\rSSF=0,0,0,0<0\rSSG=0,0,0,0<0\rSSH=1,27,27,0<14\r"
DB="DBA=0\rDBB=0\rDBC=0\rDBD=0\rDBE=0\rDBF=0\rDBG=0\rDBH=0\r"
DS="DSA=0\rDSB=0\rDSC=0\rDSD=0\rDSE=0\rDSF=0\rDSG=0\rDSH=0\r"
BW="BWA=0\rBWB=0\rBWC=0\rBWD=0\rBWE=0\rBWF=0\rBWG=0\rBWH=0\r"
ZA="ZAA=0\rZAB=0\rZAC=0\rZAD=0\rZAE=0\rZAF=0\rZAG=0\rZAH=0\r"
KD="KDA=64.00\rKDB=64.00\rKDC=64.00\rKDD=64.00\rKDE=64.00\rKDF=64.00\rKDG=64.00\rKDH=64.00\r"
KI="KIA=0.0000\rKIB=0.0000\rKIC=0.0000\rKID=0.0000\rKIE=0.0000\rKIF=0.0000\rKIG=0.0000\rKIH=0.0000\r"
KP="KPA=6.00\rKPB=6.00\rKPC=6.00\rKPD=6.00\rKPE=6.00\rKPF=6.00\rKPG=6.00\rKPH=6.00\r"
K3="K3A=64.00\rK3B=64.00\rK3C=64.00\rK3D=64.00\rK3E=64.00\rK3F=64.00\rK3G=64.00\rK3H=64.00\r"
K2="K2A=0.000\rK2B=0.000\rK2C=0.000\rK2D=0.000\rK2E=0.000\rK2F=0.000\rK2G=0.000\rK2H=0.000\r"
K1="K1A=6.00\rK1B=6.00\rK1C=6.00\rK1D=6.00\rK1E=6.00\rK1F=6.00\rK1G=6.00\rK1H=6.00\r"
ZN="ZNA=0.0000\rZNB=0.0000\rZNC=0.0000\rZND=0.0000\rZNE=0.0000\rZNF=0.0000\rZNG=0.0000\rZNH=0.0000\r"
ZP="ZPA=0.0000\rZPB=0.0000\rZPC=0.0000\rZPD=0.0000\rZPE=0.0000\rZPF=0.0000\rZPG=0.0000\rZPH=0.0000\r"
CP="CPA=-1\rCPB=-1\rCPC=-1\rCPD=-1\rCPE=-1\rCPF=-1\rCPG=-1\rCPH=-1\r"
CT="CTA=0.0000\rCTB=0.0000\rCTC=0.0000\rCTD=0.0000\rCTE=0.0000\rCTF=0.0000\rCTG=0.0000\rCTH=0.0000\r"
IL="ILA=-9.9982\rILB=-9.9982\rILC=-9.9982\rILD=-9.9982\rILE=-9.9982\rILF=-9.9982\rILG=-9.9982\rILH=-9.9982\r"
TK="TKA=0.0000\rTKB=0.0000\rTKC=0.0000\rTKD=0.0000\rTKE=0.0000\rTKF=0.0000\rTKG=0.0000\rTKH=0.0000\r"
TL="TLA=9.9982\rTLB=9.9982\rTLC=9.9982\rTLD=9.9982\rTLE=9.9982\rTLF=9.9982\rTLG=9.9982\rTLH=9.9982\r"
OF="OFA=0.0000\rOFB=0.0000\rOFC=0.0000\rOFD=0.0000\rOFE=0.0000\rOFF=0.0000\rOFG=0.0000\rOFH=0.0000\r"
FA="FAA=0.00\rFAB=0.00\rFAC=0.00\rFAD=0.00\rFAE=0.00\rFAF=0.00\rFAG=0.00\rFAH=0.00\r"
FV="FVA=0\rFVB=0\rFVC=0\rFVD=0\rFVE=0\rFVF=0\rFVG=0\rFVH=0\r"
PL="PLA=0.0000\rPLB=0.0000\rPLC=0.0000\rPLD=0.0000\rPLE=0.0000\rPLF=0.0000\rPLG=0.0000\rPLH=0.0000\r"
IT="ITA=1.0000\rITB=1.0000\rITC=1.0000\rITD=1.0000\rITE=1.0000\rITF=1.0000\rITG=1.0000\rITH=1.0000\r"
NB="NBA=0.5\rNBB=0.5\rNBC=0.5\rNBD=0.5\rNBE=0.5\rNBF=0.5\rNBG=0.5\rNBH=0.5\r"
NF="NFA=0\rNFB=0\rNFC=0\rNFD=0\rNFE=0\rNFF=0\rNFG=0\rNFH=0\r"
NZ="NZA=0.0\rNZB=0.0\rNZC=0.0\rNZD=0.0\rNZE=0.0\rNZF=0.0\rNZG=0.0\rNZH=0.0\r"
AC="ACA=1024\rACB=256000\rACC=256000\rACD=256000\rACE=256000\rACF=256000\rACG=49152\rACH=4096\r"
DC="DCA=1024\rDCB=256000\rDCC=256000\rDCD=256000\rDCE=256000\rDCF=256000\rDCG=49152\rDCH=4096\r"
SP="SPA=4000\rSPB=20\rSPC=30\rSPD=40\rSPE=50\rSPF=60\rSPG=10000\rSPH=2000\r"
PT="PTA=0\rPTB=0\rPTC=0\rPTD=0\rPTE=0\rPTF=0\rPTG=0\rPTH=0\r"
GD="GDA=0\rGDB=0\rGDC=0\rGDD=0\rGDE=0\rGDF=0\rGDG=0\rGDH=0\r"
GM="GMA=0\rGMB=0\rGMC=0\rGMD=0\rGME=0\rGMF=0\rGMG=0\rGMH=0\r"
GR="GRA=0.0000\rGRB=0.0000\rGRC=0.0000\rGRD=0.0000\rGRE=0.0000\rGRF=0.0000\rGRG=0.0000\rGRH=0.0000\r"
AG="AGA=1\rAGB=1\rAGC=1\rAGD=1\rAGE=1\rAGF=1\rAGG=1\rAGH=1\r"
AU="AUA=0.0\rAUB=0.0\rAUC=0.0\rAUD=0.0\rAUE=0.0\rAUF=0.0\rAUG=0.0\rAUH=0.0\r"
OE="OEA=0\rOEB=0\rOEC=0\rOED=0\rOEE=0\rOEF=0\rOEG=0\rOEH=0\r"
ER="ERA=16384\rERB=16384\rERC=16384\rERD=16384\rERE=16384\rERF=16384\rERG=16384\rERH=16384\r"
LD="LDA=0\rLDB=0\rLDC=0\rLDD=0\rLDE=0\rLDF=0\rLDG=0\rLDH=0\r"
OA="OAA=0\rOAB=0\rOAC=0\rOAD=0\rOAE=0\rOAF=0\rOAG=0\rOAH=0\r"
OT="OTA=30\rOTB=30\rOTC=30\rOTD=30\rOTE=30\rOTF=30\rOTG=30\rOTH=30\r"
OV="OVA=0.9438\rOVB=0.9438\rOVC=0.9438\rOVD=0.9438\rOVE=0.9438\rOVF=0.9438\rOVG=0.9438\rOVH=0.9438\r"
OW="OWA=0\rOWB=0\rOWC=0\rOWD=0\rOWE=0\rOWF=0\rOWG=0\rOWH=0\r"
HV="HVA=256\rHVB=256\rHVC=256\rHVD=256\rHVE=256\rHVF=256\rHVG=256\rHVH=256\r"
SD="SDA=256000\rSDB=256000\rSDC=256000\rSDD=256000\rSDE=256000\rSDF=256000\rSDG=256000\rSDH=256000\r"
TW="TWA=32766\rTWB=32766\rTWC=32766\rTWD=32766\rTWE=32766\rTWF=32766\rTWG=32766\rTWH=32766\r"
BB="BBA=0.00\rBBB=0.00\rBBC=0.00\rBBD=0.00\rBBE=0.00\rBBF=0.00\rBBG=0.00\rBBH=0.00\r"
BI="BIA=0\rBIB=0\rBIC=0\rBID=0\rBIE=0\rBIF=0\rBIG=0\rBIH=0\r"
BM="BMA=2000.0000\rBMB=2000.0000\rBMC=2000.0000\rBMD=2000.0000\rBME=2000.0000\rBMF=2000.0000\rBMG=2000.0000\rBMH=2000.0000\r"
BO="BOA=0.0000\rBOB=0.0000\rBOC=0.0000\rBOD=0.0000\rBOE=0.0000\rBOF=0.0000\rBOG=0.0000\rBOH=0.0000\r"
LC="LCA=0\rLCB=0\rLCC=0\rLCD=0\rLCE=0\rLCF=0\rLCG=0\rLCH=0\r"
KS="KSA=2.000\rKSB=2.000\rKSC=2.000\rKSD=2.000\rKSE=2.000\rKSF=2.000\rKSG=2.000\rKSH=2.000\r"
YA="YAA=2\rYAB=2\rYAC=2\rYAD=2\rYAE=2\rYAF=2\rYAG=2\rYAH=2\r"
YB="YBA=200\rYBB=200\rYBC=200\rYBD=200\rYBE=200\rYBF=200\rYBG=200\rYBH=200\r"
YC="YCA=4000\rYCB=4000\rYCC=4000\rYCD=4000\rYCE=4000\rYCF=4000\rYCG=4000\rYCH=4000\r"
VA="VAS=8192\rVAT=8192\r"
VD="VDS=8192\rVDT=8192\r"
VS="VSS=25000\rVST=25000\r"
IA="IA 172,16,3,65\r"
SM="SM 0,0,0,0\r"
DH=DH 0\r
IK=IK 1\r
TM=TM 1000.0000\r
EI=EI 0.0000\r
AQ1="AQ 1,2.0000\r"
AQ2="AQ 2,2.0000\r"
AQ3="AQ 3,2.0000\r"
AQ4="AQ 4,2.0000\r"
AQ5="AQ 5,2.0000\r"
AQ6="AQ 6,2.0000\r"
AQ7="AQ 7,2.0000\r"
AQ8="AQ 8,2.0000\r"
CW=CW 1.0000\r
CN0=CN 1.0000\r
CN1="CN ,-1.0000\r"
CN2="CN ,,-1.0000\r"
CN3="CN ,,,0.0000\r"
CN4="CN ,,,,0.0000\r"
MO\size=1
MO\1\Cmd=MO\r

[Data]
Variable\size=30
Variable\1\Name=CTA
Variable\1\Value=0.0000
Variable\2\Name=CTB
Variable\2\Value=0.0000
Variable\3\Name=CTC
Variable\3\Value=0.0000
Variable\4\Name=CTD
Variable\4\Value=0.0000
Variable\5\Name=CTE
Variable\5\Value=0.0000
Variable\6\Name=CTF
Variable\6\Value=0.0000
Variable\7\Name=CTG
Variable\7\Value=0.0000
Variable\8\Name=CTH
Variable\8\Value=0.0000
Variable\9\Name=CmdHvOk
Variable\9\Value=1.0000
Variable\10\Name=DcLimSwi
Variable\10\Value=1024000.0000
Variable\11\Name=Debug
Variable\11\Value=0.0000
Variable\12\Name=EO
Variable\12\Value=0.0000
Variable\13\Name=GrpAxes
Variable\13\Value=0.0000
Variable\14\Name=GrpCmd
Variable\14\Value=0.0000
Variable\15\Name=IHN
Variable\15\Value=0.0000
Variable\16\Name=LastAxis
Variable\16\Value=-1.0000
Variable\17\Name=McRevGen
Variable\17\Value=33882114.0000
Variable\18\Name=McRevSpe
Variable\18\Value=0.0000
Variable\19\Name=OldGrpAx
Variable\19\Value=-1.0000
Variable\20\Name=SpMini
Variable\20\Value=32.0000
Variable\21\Name=TstCmdEr
Variable\21\Value=58.0000
Variable\22\Name=i
Variable\22\Value=3.0000
Variable\23\Name=i16
Variable\23\Value=19.0000
Variable\24\Name=i8
Variable\24\Value=11.0000
Variable\25\Name=iBit
Variable\25\Value=8.0000
Variable\26\Name=iPE
Variable\26\Value=0.0000
Variable\27\Name=iPE8
Variable\27\Value=8.0000
Variable\28\Name=iPom
Variable\28\Value=0.0000
Variable\29\Name=iPom8
Variable\29\Value=8.0000
Variable\30\Name=iRem
Variable\30\Value=0.0000
Array\size=20
Array\1\Name=Bck
Array\1\Size=8
Array\1\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\2\Name=Cmd
Array\2\Size=8
Array\2\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\3\Name=CpMp
Array\3\Size=16
Array\3\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\4\Name=Dbw
Array\4\Size=8
Array\4\Value=10.0000, 10.0000, 10.0000, 10.0000, 10.0000, 10.0000, 10.0000, 10.0000
Array\5\Name=DcOld
Array\5\Size=8
Array\5\Value=1024.0000, 256000.0000, 256000.0000, 256000.0000, 256000.0000, 256000.0000, 49152.0000, 4096.0000
Array\6\Name=EnRem
Array\6\Size=16
Array\6\Value=1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\7\Name=GrAxis
Array\7\Size=8
Array\7\Value=-1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000
Array\8\Name=GrRatio
Array\8\Size=8
Array\8\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\9\Name=GrTemp
Array\9\Size=24
Array\9\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, -1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\10\Name=GrpAx
Array\10\Size=4
Array\10\Value=0.0000, 0.0000, 0.0000, 0.0000
Array\11\Name=IniPos
Array\11\Size=8
Array\11\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\12\Name=IniSpeed
Array\12\Size=8
Array\12\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\13\Name=IniTyp
Array\13\Size=8
Array\13\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\14\Name=NbRetry
Array\14\Size=24
Array\14\Value=5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 5.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\15\Name=Percent
Array\15\Size=8
Array\15\Value=1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000
Array\16\Name=Pos
Array\16\Size=16
Array\16\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 2147483647.0000, 2147483647.0000, 2147483647.0000, 2147483647.0000, 2147483647.0000, 2147483647.0000, 2147483647.0000, 2147483647.0000
Array\17\Name=PosStat
Array\17\Size=16
Array\17\Value=0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\18\Name=SpBackup
Array\18\Size=24
Array\18\Value=4000.0000, 20.0000, 30.0000, 40.0000, 50.0000, 60.0000, 10000.0000, 2000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 4000.0000, 20.0000, 30.0000, 40.0000, 50.0000, 60.0000, 10000.0000, 2000.0000
Array\19\Name=StabTime
Array\19\Size=16
Array\19\Value=100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 100.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000
Array\20\Name=Stat
Array\20\Size=8
Array\20\Value=224.0000, 224.0000, 224.0000, 224.0000, 224.0000, 224.0000, 224.0000, 224.0000

[Program]
Program="'************************************************************************\n'*            *\n'*      Microcode generique V2.5    *\n'*            *\n'************************************************************************\n'* Microcode Generique :  Version : 2.5.0.2   *\n'*      Date : 12-11-2010   *\n'*      Auteur : Benjamin Gombert- Matthieu Cerato  *\n'*  Dernieres modifications :  02-12-2016    *\n'*  =======================       *\n'* 2.5.0.2 - Erreur corrige: pointer ~b (sous #CMDPOM) n'a pas          *\n'*    ete initiee correctement.\n'* 2.5.0.0 - Ajout du controle des SSI pour initialisation          *\n'*   - Ajout de detection de type de carte pour parametre HV-SD         *\n'*     et restauration de la decel apres mouvement.\n'* 2.4.0.1 - Ajout du forcage de la vitesse mini a 32cnt/s (SpMini) *\n'*    sur les commandes de Jog (Forward - Backward).  *\n'* 2.4.0.0 - Ajout du support de la property AxisInitSpeed via  *\n'*    IniSpeed[] pour definir la vitesse de prise d'origine. *\n'* 2.3.0.7 - Modification de la syntaxe de la routine #LIMSWI,  *\n'*    reduction du nombre de IF empiles.    *\n'* 2.3.0.6 - Correction des lenteurs microcode lorsqu'une erreur de *\n'*    poursuite est excessive sur un servomoteur (cf. #POSERR). *\n'* 2.3.0.5 - Ajout de la fonctionnalite Correction de l'erreur  *\n'*    statique de position des moteurs pas-a-pas.   *\n'* 2.3.0.4 - Ajout de la fonctionnalite Commande Groupee   *\n'*  - Autorisation de la commande Stop meme si le mouvement est *\n'*    interdit au Device (Stat[]_bit6).     *\n'* 2.3.0.3 - Ajout de la fonction SettlingTime : remplacement de la *\n'*    variable TempStab par le tableau StabTime[].   *\n'*  - Amelioration des arrondis sur les DefinePosition et  *\n'*    consignes de Position (ajout de @RND).    *\n'* 2.3.0.2 - Modification de la routine #POSCHK et de la tache #PECORR *\n'*    pour eviter qu'un positionnement stoppe a bas niveau  *\n'*    (terminal) ne soit relance.      *\n'*  - Modification de la commande de STOP pour stopper une *\n'*    eventuelle correction d'erreur de poursuite.   *\n'* 2.3.0.1 - Modification de la routine #CMDERR pour le traiter les *\n'*    erreurs des threads specifiques (amelioration de  *\n'*    l'integration des microcodes specifiques).   *\n'*  - Utilisation de la variable LastAxis pour pointer les *\n'*    axes mis en mouvement par les threads specifiques.  *\n'* 2.3.0.0 - Ajout de la possibilite de stopper les moteurs en erreur *\n'*    de poursuite dans le mode Maintenance position sans faire *\n'*    de correction (conditionne par le bit CpMp[]_bit4).  *\n'*  - Ajout de la redefinition de position en debut de JOG pour *\n'*    les steppers avec codeur.      *\n'*  - Desactivation de la fonction Maintenance position en *\n'*    mode Remote.        *\n'* 2.2.0.9 - Modification de la routine CMDERR pour interdire l'acti- *\n'*    vation du mode gearing sur un axe qui est OFF ou en butee *\n'* 2.2.0.8 - Correction de la sauvegarde de la vitesse en mode gearing *\n'*    pour des mises a jour repetees sur un meme axe esclave *\n'*    (bug Mantis 6984)       *\n'* 2.2.0.7 - Definition de Jogs nulls sur les axes esclaves et  *\n'*    restauration de la vitesse apres mise hors synchro  *\n'*    (bug Mantis 6413)       *\n'* 2.2.0.6 - Mise a jour des bits maitre (Stat[]_bit15) et esclave *\n'*    (Stat[]_bit14) apres avoir rencontre une butee  *\n'*  - Suppression des commentaires sur les lignes de Label *\n'*  - Ajout des declarations de variables non initialisees *\n'*    (nbBl, nbFl, nbFh et nbFi)      *\n'* 2.2.0.5 - Correction des tests de backlash Bck[]    *\n'*  - Ajout des attributs Percent[] et NbRetry[], modification *\n'*    du comptage du nombre de reessais par reessais divergents *\n'*    (bug Mantis 4489)       *\n'*  - Modification des bits de CpMp[] (Remote & Maintenance) *\n'*  - Correction de l'etat Moving des axes lors du reset Cbox *\n'*    et lors de la sortie du mode slit (bug Mantis 4455)  *\n'*  - Redefinition de la position moteur en fonction du codeur *\n'*    pour un Stepper avec Codeur avant un positionnement  *\n'************************************************************************\n'* Microcode Specifique :  Version : -    *\n'*      Date : -    *\n'*      Auteur : -    *\n'**************************** Commentaires ******************************\n'* -les variables de type ~x sont des pointeurs d'axe   *\n'*  ~x peut prendre les valeurs 0 a 7 pour designer les axes A a H *\n'* ~a - pointeur d'axe de la boucle principale    *\n'* ~b - pointeur d'axe de la tache de prise d'origine   *\n'* ~c - pointeur d'axe de la routine automatique #POSERR   *\n'* ~d - pointeur d'axe de la routine automatique #LIMSWI   *\n'* ~e - pointeur d'axe de la tache de correction d'erreur  *\n'* ~f - pointeur d'axe de la routine de commande groupee   *\n'* ~g - disponnible         *\n'* ~h - disponnible         *\n'* -les variables de type iXX sont des pointeurs de tableaux  *\n'******************************* Taches *********************************\n'* 0- Tache principale executee automatiquement a la mise sous tension *\n'* 1- Tache dediee aux prises d'origines      *\n'* 2- Tache dediee a la correction d'erreur de position   *\n'* 3- Tache reservee au microcode generique     *\n'* 4- Tache reservee aux microcodes specifiques     *\n'* 5- Tache reservee aux microcodes specifiques     *\n'* 6- Tache reservee aux microcodes specifiques     *\n'* 7- Tache reservee aux microcodes specifiques     *\n'************************************************************************\n'\n#AUTO\n'\nMcRevGen=$02050002;' Version Microcode Generique\n'\nMcRevSpe=$00000000;' Version Microcode Specifique\n'\nDA*[];'  Desallocation des tableaux en memoire\n'   Declaration des tableaux :\nDM Stat[8];' Etat de l'axe\nDM Cmd[8];'  Commande a executer\nDM IniTyp[8];' Type d'initialisation\nDM IniPos[8];' Valeur de la position initialisee\nDM IniSpeed[8];' Valeur de la vitesse d'initialisation\nDM Pos[16];' Position a atteindre\n'   (0  a 7  : Position a atteindre   )\n'   (8  a 15 : Derniere erreur de positionnement )\nDM Dbw[8];'  Dead BandWidth = precision du positionnement\nDM Bck[8];'  Backlash\nDM PosStat[16];' (0  a 7  : Etat du positionnement    )\n'   (8  a 15 : Prise d'origine sur une butee en cours )\nDM NbRetry[24];' Compteur nombre reessais de positionnement\n'   (0  a 7  : reessais Statiques )\n'   (8  a 15 : reessais Dynamiques)\n'   (16 a 23 : reessais Statiques )\nDM Percent[8];' Coefficient de positionnement par approches successives\nDM StabTime[16];' Parametres d'attende de stabilisation du positionnement\n'   (0  a 7  : Duree de stabilisation en ms )\n'   (8  a 15 : Timer de stabilisation)\nDM SpBackup[24];' Vitesses memorisees\n'   (0  a 7  : correction d'erreur de position et mode Gearing )\n'   (8  a 15 : vitesse en mode JOG     )\n'   (16 a 23 : vitesse en mode REMOTE     )\nDM DcOld[8];'  Old values of Deceleration Values\nDM GrAxis[8];' Axe maitre en mode gearing\nDM GrRatio[8];' Ratio maitre/esclave en mode gearing\nDM GrTemp[24];' Variable de traitement du mode Gearing\n'   (0  a 7  : Variable temporaire de traitement du mode Gearing)\n'   (8  a 15 : Axe maitre actif      )\n'   (16 a 23 : Gear ratio applique     )\nDM CpMp[16];' Presence Codeur et Maintenance de la Position\n'   (0 a 7  : Valeurs actuelles de CpMp[])\n'   (8 a 15 : Anciennes valeurs de CpMp[])\nDM EnRem[16];' Enable Remote\n'   (0 a 7  : Activation/Desactivation du mode Remote)\n'   (8 a 15 : Etat des axes en remote (ON/OFF)  )\nDM GrpAx[4];' Pointeur d'axes pour commande groupee (ASCII)\n'\n' Constantes de parametrage du fonctionnement :\nSpMini=32;'  Vitesse de rotation minimum\nDcLimSwi=1024000;'Deceleration minimum lors de l'activation d'une butee\nGrpCmd=0;'  Commande groupee : pas de commande en cours\nGrpAxes=0;'  Pointeur d'axes pour commande groupee (8 bits)\nOldGrpAx=-1;' Valeur memorisee du pointeur d'axes pour commande groupee\nDebug=0;'  Mode DEBUG desactive par defaut\n'\n' Detection support du HV par le controlleur (DMC-41x3)\nTstCmdEr=58;'        Declaration test sur operande inexistante pour #CMDERR\nCmdHvOk=1\nJP#HV_OK,(_HVA>-1)\nCmdHvOk=0\n#HV_OK\n'\nJS#INIT;'  Appel de la routine d'initialisation\nJS#INITSPE;' Appel de la routine d'init des variables specifiques\ni=0;i8=8;i16=16;iBit=1;~a=0;'   Initialisation pointeurs d'axes\niPom=0;iPom8=8;iRem=0;iPE=0;iPE8=8;' Initialisation des differents index\n'\n'============================= Boucle principale ============================\n#MLOOP\n'\n JS#CPMP,(CpMp[i]<>CpMp[i8]);'  Si CpMp modifie, appel de la routine CpMp\n' JS#SPE_SEQ;'    Appel sequentiel de la routine specifique\n JS#GRP_CMD,GrpCmd>0;'   Appel de la routine execution des commandes groupees\n JS#CMD,Cmd[i]<>0;'   Appel de la routine d'execution des commandes\n JS#POSCHK,(PosStat[i]>0)&(_BG~a=0);'Si positionnement termine, controle\n JS#MOVCHK,(_SC~a=0)&(Stat[i]&$200C=4);'Controle erreur de poursuite (SPM)\n JS#REMOTE,(CpMp[i]&$8>0);'  Si mode Remote autorise, execution de la routine\n i=i+1;i8=i8+1;i16=i16+1;iBit=iBit*2;~a=i;'Increment pointeurs d'axes\n'\nJP#MLOOP,i<8\ni=0;i8=8;i16=16;iBit=1;~a=0;'  Reinitialisation des variables de boucle\n'\nJP#MLOOP\nEN\n'=========================== Fin Boucle principale ==========================\n'\n'===== Initialisation des variables =====\n#INIT\ni=0;i8=8;i16=16;~a=0;'  Initialisation pointeur de tableau et pointeur d'axe\n#ILOOP\n'\n'*** Parametres microcode ***\nPos[i]=0;'   Position a atteindre\nPos[i8]=$7FFFFFFF;' Derniere erreur de positionnement\nDbw[i]=10;'   Dead BandWidth = precision du positionnement\nBck[i]=0;'   Backlash nul par defaut\nPosStat[i]=0;'  Pas de mouvement en cours au demarrage\nPosStat[i8]=0;'  Pas de Prise d'origine sur une butee en cours\nNbRetry[i]=5;'  Nombre de reessais maximum de positionnement\nNbRetry[i8]=0;'  Compteur nombre reessais de positionnement (Dynamique)\nNbRetry[i16]=0;'  Compteur nombre reessais de positionnement (Statique)\nPercent[i]=1;'  Coefficient de positionnement par approches successives\nStabTime[i]=100;'  Valeur de l'attente de stabilisation du positionnement (ms)\nSpBackup[i]=_SP~a;' Vitesse memorisee pour correction d'erreur de position\nDcOld[i]=_DC~a;' Storing current values of deceleration values into array\nSpBackup[i8]=0;'  Parametre memorise du mode jog\nSpBackup[i16]=_SP~a;' Vitesse memorise pour mode remote\nStat[i]=$E0;'  Etat par defaut :\n'    OnOff_autorise_au_device = 1  ($20)\n'    Mouvement_autorise_au_device = 1 ($40)\n'    Positionnement_termine = 1  ($80)\nCmd[i]=0;'   Commandes : pas de commande en cours\nIniTyp[i]=0;'  Prise de ref par defaut, faite sur Define Position DP\nIniPos[i]=0;'  Valeur de la position utilisee lors de la prise de ref\nGrAxis[i]=-1;'          Pas d'axe maitre en mode gearing au demarrage\nGrRatio[i]=0;'          Ratio maitre/esclave en mode gearing nul\nGrTemp[i8]=-1;'  Pas d'axe actif en mode gearing au demarrage\nGrTemp[i16]=0;'  Gear ratio nul au demarrage\nEnRem[i]=1;'  Mote remote autorise par le Microcode\n'\nStat[i]=(Stat[i]&@COM[$1])|(@ABS[_MT~a]=1);' MaJ du type de moteur dans Stat\nCpMp[i]=0;'   CpMp : pas de codeur, pas de maintenance position, pas de remote\nCpMp[i8]=-1;'   Forcage de la mise a jour des parametres associes a CpMp\n'\ni=i+1;i8=i8+1;i16=i16+1;~a=i;' Increment pointeur de tableau et pointeur d'axe\nJP#ILOOP,(i<8)\nEN\n'\n'===== Execution des commandes =====\n#CMD\nIF((Cmd[i]&1)<>0);JS#CMDST;'        Stop\nELSE;IF((Cmd[i]&2)<>0);JgDir= 1;JS#CMDJG,(Stat[i]&$40)<>0;'   Jog +\nELSE;IF((Cmd[i]&4)<>0);JgDir=-1;JS#CMDJG,(Stat[i]&$40)<>0;'   Jog -\nELSE;IF((Cmd[i]&$108)<>0);JS#CMDPOS,(Stat[i]&$40)<>0;'   Positionnement\nELSE;IF((Cmd[i]&$10)<>0);JS#CMDPOM,(Stat[i]&$40)<>0;'    Prise d'Origine Axe\nELSE;IF(((Cmd[i]&$20)<>0)&((Stat[i]&$20)<>0));SH~a;'    Motor On\nELSE;IF(((Cmd[i]&$40)<>0)&((Stat[i]&$20)<>0));MO~a;'    Motor Off\nELSE;IF((Cmd[i]&$80)<>0);JS#CMDGEAR;'      Mise a jour Gearing\nENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF\nCmd[i]=0;'           Commande traitee\nEN\n'\n'=========== Commande Stop ===========\n#CMDST\nIF((_XQ1>=0)&(i=iPom));'  Si la tache de prise de ref est executee,\n HX1;'      Arret de la tache de prise de ref\n Stat[i]=((Stat[i]|$880)&@COM[$300])\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Prise_Ref_en_cours = 0 ($200)\n'       MAJ bit Echec_Prise_Ref = 1  ($800)\n PosStat[i8]=0;'    Pas de Prise d'origine sur butee en cours\nENDIF\nIF(_XQ2>=0);'    Si la tache de correction d'erreur est executee,\n Stat[i]=Stat[i]&@COM[$1000];'  MAJ bit Attente_de_correction = 0 ($1000)\n IF(i=iCO);'     Si l'axe est en cours de correction,\n  HX2;'      Arret de la correction,\n  XQ#CORCHK,2;'    Controle des autres axes en erreur de correction,\n ENDIF\n NbRetry[i8]=NbRetry[i];'  Arret des reessais dynamiques\n SP~a=spSave;'    Restauration de la vitesse avant correction\nENDIF\nST~a;'     Arret de l'axe\nSpBackup[i8]=0;'    Mode JOG off\nPosStat[i]=0;'    Pas de positionnement en cours\nStat[i]=(Stat[i]|$80)&@COM[$21100];'MAJ bit Positionnement_termine = 1 ($80)\n'      MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'      MAJ bit Attente_de_correction = 0 ($1000)\n'      MAJ bit Mode_lock_position_actif =0 ($20000)\nEN\n'\n'============ Commande Jog ============\n#CMDJG\nDcOld[i]=_DC~a;' Storing old value of deceleration\nIF((@ABS[_MT~a]<>1)&(Stat[i]&$2>0));' Si STEPPER avec CODEUR,\n DP~a=@RND[(_TP~a/_YC~a)*_YA~a*_YB~a];' Defnition position moteur selon codeur\nENDIF\nIF(_SP~a<SpMini);SP~a=SpMini;ENDIF;'Verification des vitesses trop faibles\nSpBackup[i8]=JgDir*_SP~a;'  Definition de la vitesse signee du Jog\nJG~a=SpBackup[i8];'   Commande du mouvement\nStat[i]=(Stat[i]&@COM[$22180]);' MAJ bit Positionnement_termine = 0 ($80)\n'      MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'      MAJ bit Erreur_de_poursuite = 0 ($2000)\n'      MAJ bit Mode_lock_position_actif =0 ($20000)\nNbRetry[i8]=0;'    Initialisation du nombre de reessais dynamiques\nBG~a;'     Execution du mouvement\nEN\n'\n'===== Commande de positionnement =====\n#CMDPOS\n'\nIF((@ABS[_MT~a]<>1)&(Stat[i]&$2>0));' Si STEPPER avec CODEUR,\n DP~a=@RND[(_TP~a/_YC~a)*_YA~a*_YB~a];' Defnition position moteur selon codeur\nENDIF\nActualPa=_PA~a;'    Recuperation de la position moteur\nIF(@ABS[Pos[i]-ActualPa]<=Dbw[i]);' Si position actuelle dans la plage cible\n Stat[i]=((Stat[i]|$80)&@COM[$2100]);' On ne bouge pas\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Erreur_de_poursuite = 0 ($2000)\nELSE;'     Si position actuelle hors de la plage cible\nDcOld[i]=_DC~a;' Storing old value of deceleration\n Stat[i]=(Stat[i]&@COM[$2180]);' MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Erreur_de_poursuite = 0 ($2000)\n IF(_SP~a<SpMini);SP~a=SpMini;ENDIF;'Verification des vitesses trop faibles\n SpBackup[i]=_SP~a;'   Mise en memoire de la vitesse\n ' Gestion du Backlash\n ' Si (Pd-Pa+Bck) est du signe de Bck,\n IF(((Bck[i]/@ABS[Bck[i]])*(ActualPa-Pos[i]))>0)\n  PosStat[i]=3;'   Declaration: positionnement avec backlash en cours\n  PA~a=(Pos[i]-Bck[i]);BG~a;' Positionnement avec Backlash\n ELSE;'     Si (Pd-Pa+Bck) n'est pas du signe de Bck,\n  PosStat[i]=2;'   Declaration: positionnement sans backlash en cours\n  PA~a=@RND[(@RND[Pos[i]]-ActualPa)*Percent[i]]+ActualPa;BG~a;' Positionnement\n ENDIF\n Pos[i8]=$7FFFFFFF;'   Initialisation de la derniere erreur de positionnement\n NbRetry[i8]=0;'    Initialisation du nombre de reessais dynamiques\n NbRetry[i16]=0;'    Initialisation nombre de reessais statiques\n SpBackup[i8]=0;'    Mode JOG off\nENDIF\n'MAJ bit Mode_lock_position_actif ($20000)\nStat[i]=(Stat[i]&@COM[$20000])|((Cmd[i]&$100)*$200)\n'\nEN\n'\n'===== Execution de la tache de Prise de Reference =====\n#CMDPOM\nIF(_XQ1<0);'   Si la tache de prise de ref n'est pas executee,\n iPom=i;iPom8=i+8;~b=i;' Mise en memoire des pointeurs de l'axe de prise de ref\n DcOld[iPom]=_DC~b;' Storing old value of deceleration\n XQ#POM,1;'   Execution de la tache de prise de ref\nENDIF\nEN\n'\n'======= Tache de Prise d'Origine Axe =======\n#POM\nStat[iPom]=((Stat[iPom]|$200)&@COM[$22D86])\n'        MAJ bit Presence_Codeur = 0  ($2)\n'        MAJ bit Maintenance_Position = 0 ($4)\n'        MAJ bit Positionnement_termine = 0 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'        MAJ bit Prise_Ref_en_cours= 1  ($200)\n'        MAJ bit Prise_Ref_Faite = 0  ($400)\n'        MAJ bit Echec_Prise_Ref = 0  ($800)\n'        MAJ bit Erreur_de_poursuite = 0 ($2000)\n'        MAJ bit Mode_lock_position_actif =0 ($20000)\nST~b;AM~b;'       Arret de l'axe\nPosStat[iPom]=0;'      Pas de positionnement en cours\nIF(@ABS[_MT~b]<>1);YS~b=0;ENDIF;'   Desactivation Maintenance Position\nSpBackup[iPom8]=0;'     Mode JOG off\nPosStat[iPom8]=0;'     Init pas de Prise d'origine sur butee en cours\nPomSpBck=_SP~b;'      Memorisation de la vitesse avant prise d'origine\nPomSpeed=_SP~b;'      Memorisation de la vitesse de prise d'origine\nIF(IniSpeed[iPom]>SpMini);PomSpeed=IniSpeed[iPom];ENDIF;'Property AxisInitSped\nnbBl=(IniTyp[iPom]&$F000)/$1000;'   Nombre de recherches de la Back Limit\nnbFl=(IniTyp[iPom]&$0F00)/$100;'   Nombre de recherches de la Fwd Limit\nnbFh=(IniTyp[iPom]&$0070)/$10;'   Nombre de recherches du capteur Home\nnbFi=(IniTyp[iPom]&$0007);'    Nombre de recherches de l'Index\nIF((IniTyp[iPom]&$F000)<>0);JS#POMBL;'  Prise d'origine sur Back Limit\nELSE;IF((IniTyp[iPom]&$0F00)<>0);JS#POMFL;' Prise d'origine sur Fwd Limit\nENDIF;ENDIF\nIF((IniTyp[iPom]&$0070)<>0);JS#POMFH;ENDIF;' Prise d'origine sur Find Home\nIF((IniTyp[iPom]&$0007)<>0);JS#POMFI;ENDIF;' Prise d'origine sur Find Index\nIF(@ABS[_MT~b]<>1);'     Si moteur STEPPER\n IF((CpMp[iPom]&1)>0);'     Si codeur INCREMENTAL\n  DP~b=IniPos[iPom];'     Init Position Principale\n  DE~b=@RND[(IniPos[iPom]/(_YA~b*_YB~b))*_YC~b];' Init Position Auxiliaire\n ELSE;IF((CpMp[iPom]&2)>0);'    Si codeur ABSOLU\n  DP~b=@RND[(_TP~b/_YC~b)*_YA~b*_YB~b];'  Init Position Principale\n ELSE;'       Si PAS de codeur\n  DP~b=IniPos[iPom];'     Init Position Principale\n ENDIF;ENDIF\nELSE;'       Si moteur SERVO ou PIEZO\n DP~b=IniPos[iPom];'     Init Position Principale\n DE~b=0;'       Init Position Auxiliaire\nENDIF\nStat[iPom]=((Stat[iPom]&@COM[$206])|$480)|(((CpMp[iPom]&3)>0)*2)|(CpMp[iPom]&4)\n'        MAJ bit Codeur_Present   ($2)\n'        MAJ bit Maintenance_Position  ($4)\n'        MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Prise_Ref_en_cours= 0  ($200)\n'        MAJ bit Prise_Ref_Faite = 1  ($400)\nCpMp[iPom8]=CpMp[iPom];'    Mise en memoire de CpMp[iPom]\nEN\n'========= Fin Prise d'Origine Axe ==========\n'\n'** POM sur Backward Limit **\n#POMBL\nspBl=_SP~b;'    Mise en memoire de la vitesse\niBl=0;'     Index de la boucle BL (iterations)\nIF(IniSpeed[iPom]>SpMini);SP~b=IniSpeed[iPom];ENDIF;'  Property AxisInitSpeed\n#BLLOOP\n PosStat[iPom8]=-1;'   Prise d'origine sur la butee - en cours\n IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n lrStat=_LR~b;'    Mise en memoire de l'etat de la butee\n IF(_LR~b);JG~b=-_SP~b;BG~b;'  Limite inactive : recherche de la butee\n ELSE;JG~b=_SP~b;BG~b;ENDIF;'  Limite active : degagement de la butee\n#BLWAIT;JP#BLWAIT,lrStat=_LR~b;' Attente du changement d'etat de la butee\n ST~b;AM~b;'     Arret de l'axe apres front sur la butee\n PomSpeed=_SP~b;'    Memorisation de la derniere vitesse de prise d'origine\n SP~b=_SP~b/5;'    Reduction de la vitesse a chaque iteration\n iBl=iBl+1;'     Increment de l'index de boucle BL\nJP#BLLOOP,iBl<nbBl;'   Iteration suivante\nSP~b=spBl;'     Restauration de la vitesse\nWT StabTime[iPom];'   Attente de stabilisation\nPosStat[iPom8]=0;'   Pas de Prise d'origine sur butee en cours\nEN\n'** POM sur Forward Limit ***\n#POMFL\nspFl=_SP~b;'    Mise en memoire de la vitesse\niFl=0;'     Index de la boucle FL (iterations)\nIF(IniSpeed[iPom]>SpMini);SP~b=IniSpeed[iPom];ENDIF;'  Property AxisInitSpeed\n#FLLOOP\n PosStat[iPom8]=1;'   Prise d'origine sur la butee + en cours\n IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n lfStat=_LF~b;'    Mise en memoire de l'etat de la butee\n IF(_LF~b);JG~b=_SP~b;BG~b;'  Limite inactive : recherche de la butee\n ELSE;JG~b=-_SP~b;BG~b;ENDIF;'  Limite active : degagement de la butee\n#FLWAIT;JP#FLWAIT,lfStat=_LF~b;' Attente du changement d'etat de la butee\n ST~b;AM~b;'     Arret de l'axe apres front sur la butee\n PomSpeed=_SP~b;'    Memorisation de la derniere vitesse de prise d'origine\n SP~b=_SP~b/5;'    Reduction de la vitesse a chaque iteration\n iFl=iFl+1;'     Increment de l'index de boucle FL\nJP#FLLOOP,iFl<nbFl;'   Iteration suivante\nSP~b=spFl;'     Restauration de la vitesse\nWT StabTime[iPom];'   Attente de stabilisation\nPosStat[iPom8]=0;'   Pas de Prise d'origine sur butee en cours\nEN\n'**** POM sur Find Home *****\n#POMFH\nsgnFh=(IniTyp[iPom]&$0080)/$80;' Sens de rotation pour la recherche\nspFh=_SP~b;dirFh=sgnFh;'  Mise en memoire de la vitesse et du signe\niFh=0;'     Index de la boucle FH (iterations)\nIF(IniSpeed[iPom]>SpMini);SP~b=IniSpeed[iPom];ENDIF;'  Property AxisInitSped\n#FHLOOP\n IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n hmStat=_HM~b;'    Mise en memoire de l'etat du capteur Home\n IF(dirFh=0);JG~b=_SP~b;BG~b;'  Bit de signe positif : rotation +\n ELSE;JG~b=-_SP~b;BG~b;ENDIF;'  Bit de signe negatif : rotation -\n#FHWAIT;JP#FHWAIT,(hmStat=_HM~b);' Front sur HM ou butee\n ST~b;AM~b;'     Arret de l'axe apres front sur HM\n PomSpeed=_SP~b;'    Memorisation de la derniere vitesse de prise d'origine\n SP~b=_SP~b/5;'    Reduction de la vitesse a chaque iteration\n dirFh=(dirFh=0);'    Changement de direction (complement)\n iFh=iFh+1;'     Increment de l'index de boucle FH\nJP#FHLOOP,iFh<nbFh;'   Iteration suivante\nSP~b=spFh;'     Restauration de la vitesse\nEN\n'**** POM sur Find Index ****\n#POMFI\nsgnFi=(IniTyp[iPom]&$0008)/$8;'Sens de rotation pour la recherche\nspFi=_SP~b;dirFi=sgnFi;'       Mise en memoire de la vitesse et du signe\nSP~b=PomSpeed;'                Utilisation derniere vitesse prise d'origine\niFi=0;'                        Index de la boucle FI (iterations)\n#FILOOP\n IF(_SP~b<SpMini);SP~b=SpMini;ENDIF;'Verification des vitesses trop faibles\n IF(CmdHvOk);'               Si la commande HV est supportee,\n  HV~b=_SP~b/5;'              Vitesse de retour sur index latche reduite\n  IF(_HV~b<SpMini);HV~b=SpMini;ENDIF;'Verification vitesse HV trop faible\n ENDIF\n IF(dirFi=0);JG~b=_SP~b;'    Bit de signe positif : rotation +\n ELSE;JG~b=-_SP~b;ENDIF;'    Bit de signe negatif : rotation -\n FI~b;BG~b;'                 Lancement de la recherche d'index\n AM~b;'                      Attente index trouve\n SP~b=_SP~b/5;'              Reduction de la vitesse a chaque iteration\n dirFi=(dirFi=0);'           Changement de direction (complement)\n iFi=iFi+1;'                 Increment de l'index de boucle FI\nJP#FILOOP,iFi<nbFi;'           Iteration suivante\nSP~b=spFi;'                    Restauration de la vitesse\nEN\n'===== Fin Prise d'Origine Axe =====\n'\n'===== Commande de Mise a Jour du mode Gearing =====\n#CMDGEAR\nIF((0<=GrAxis[i])&(GrAxis[i]<=7)&(GrAxis[i]<>i))\n IF(GrAxis[i]=0);GA~a=A;ENDIF;' Codeur Principal A Maitre\n IF(GrAxis[i]=1);GA~a=B;ENDIF;' Codeur Principal B Maitre\n IF(GrAxis[i]=2);GA~a=C;ENDIF;' Codeur Principal C Maitre\n IF(GrAxis[i]=3);GA~a=D;ENDIF;' Codeur Principal D Maitre\n IF(GrAxis[i]=4);GA~a=E;ENDIF;' Codeur Principal E Maitre\n IF(GrAxis[i]=5);GA~a=F;ENDIF;' Codeur Principal F Maitre\n IF(GrAxis[i]=6);GA~a=G;ENDIF;' Codeur Principal G Maitre\n IF(GrAxis[i]=7);GA~a=H;ENDIF;' Codeur Principal H Maitre\n GR~a=GrRatio[i];'    Definition du Gear Ratio\n GrTemp[i8]=GrAxis[i];'   Memorisation des axes maitres actifs\n GrTemp[i16]=GrRatio[i];'  Memorisation du gear ratio applique\n IF(Stat[i]&$4000=0);'   Si l'axe n'etait pas deja esclave\n  SpBackup[i]=_SP~a;'  Mise en memoire de la vitesse de l'axe esclave\n ENDIF\n Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'       MaJ bit Axe_Esclave = 1   ($4000)\n'       MaJ bit OnOff_Autorise = 0  ($20)\n'       MaJ bit Mvmt_Autorise = 0  ($40)\n'       MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n JG~a=0; BG~a;'    Definition d'un Jog nul sur l'axe esclave\nELSE;IF(GrAxis[i]=8)\n GA~a=N;'     Axe Virtuel N Maitre\n GR~a=GrRatio[i];'    Definition du Gear Ratio\n GrTemp[i8]=GrAxis[i];'   Memorisation des axes maitres actifs\n GrTemp[i16]=GrRatio[i];'  Memorisation du gear ratio applique\n IF(Stat[i]&$4000=0);'   Si l'axe n'etait pas deja esclave\n  SpBackup[i]=_SP~a;'  Mise en memoire de la vitesse de l'axe esclave\n ENDIF\n Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'       MaJ bit Axe_Esclave = 1   ($4000)\n'       MaJ bit OnOff_Autorise = 0  ($20)\n'       MaJ bit Mvmt_Autorise = 0  ($40)\n'       MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n JG~a=0; BG~a;'    Definition d'un Jog nul sur l'axe esclave\nELSE;IF((10<=GrAxis[i])&(GrAxis[i]<=17)&(GrAxis[i]-10<>i))\n IF(GrAxis[i]=10);GA~a=CA;ENDIF;' Position Commandee CA Maitre\n IF(GrAxis[i]=11);GA~a=CB;ENDIF;' Position Commandee CB Maitre\n IF(GrAxis[i]=12);GA~a=CC;ENDIF;' Position Commandee CC Maitre\n IF(GrAxis[i]=13);GA~a=CD;ENDIF;' Position Commandee CD Maitre\n IF(GrAxis[i]=14);GA~a=CE;ENDIF;' Position Commandee CE Maitre\n IF(GrAxis[i]=15);GA~a=CF;ENDIF;' Position Commandee CF Maitre\n IF(GrAxis[i]=16);GA~a=CG;ENDIF;' Position Commandee CG Maitre\n IF(GrAxis[i]=17);GA~a=CH;ENDIF;' Position Commandee CH Maitre\n GR~a=GrRatio[i];'    Definition du Gear Ratio\n GrTemp[i8]=GrAxis[i]-10;'  Memorisation des axes maitres actifs\n GrTemp[i16]=GrRatio[i];'  Memorisation du gear ratio applique\n IF(Stat[i]&$4000=0);'   Si l'axe n'etait pas deja esclave\n  SpBackup[i]=_SP~a;'  Mise en memoire de la vitesse de l'axe esclave\n ENDIF\n Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'       MaJ bit Axe_Esclave = 1   ($4000)\n'       MaJ bit OnOff_Autorise = 0  ($20)\n'       MaJ bit Mvmt_Autorise = 0  ($40)\n'       MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n JG~a=0; BG~a;'    Definition d'un Jog nul sur l'axe esclave\nELSE;IF((20<=GrAxis[i])&(GrAxis[i]<=27)&(GrAxis[i]-20<>i))\n IF(GrAxis[i]=20);GA~a=DA;ENDIF;' Codeur Auxiliaire DA Maitre\n IF(GrAxis[i]=21);GA~a=DB;ENDIF;' Codeur Auxiliaire DB Maitre\n IF(GrAxis[i]=22);GA~a=DC;ENDIF;' Codeur Auxiliaire DC Maitre\n IF(GrAxis[i]=23);GA~a=DD;ENDIF;' Codeur Auxiliaire DD Maitre\n IF(GrAxis[i]=24);GA~a=DE;ENDIF;' Codeur Auxiliaire DE Maitre\n IF(GrAxis[i]=25);GA~a=DF;ENDIF;' Codeur Auxiliaire DF Maitre\n IF(GrAxis[i]=26);GA~a=DG;ENDIF;' Codeur Auxiliaire DG Maitre\n IF(GrAxis[i]=27);GA~a=DH;ENDIF;' Codeur Auxiliaire DH Maitre\n GR~a=GrRatio[i];'    Definition du Gear Ratio\n GrTemp[i8]=GrAxis[i]-20;'  Memorisation des axes maitres actifs\n GrTemp[i16]=GrRatio[i];'  Memorisation du gear ratio applique\n IF(Stat[i]&$4000=0);'   Si l'axe n'etait pas deja esclave\n  SpBackup[i]=_SP~a;'  Mise en memoire de la vitesse de l'axe esclave\n ENDIF\n Stat[i]=(Stat[i]|$4000)&@COM[$1E0]\n'       MaJ bit Axe_Esclave = 1   ($4000)\n'       MaJ bit OnOff_Autorise = 0  ($20)\n'       MaJ bit Mvmt_Autorise = 0  ($40)\n'       MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n JG~a=0; BG~a;'    Definition d'un Jog nul sur l'axe esclave\nELSE\n GR~a=0;'     Gear Ratio Nul (Pas d'axe Maitre)\n ST~a;'     Arret du Jog nul de l'axe esclave\n SP~a=SpBackup[i];'   Restauration de la vitesse de l'axe esclave\n Stat[i]=(Stat[i]|$E0)&@COM[$4100]\n'       MaJ bit Axe_Esclave = 0   ($4000)\n'       MaJ bit OnOff_Autorise = 1  ($20)\n'       MaJ bit Mvmt_Autorise = 1  ($40)\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n GrTemp[i8]=-1;'    Memorisation: pas d'axe maitre\n GrTemp[i16]=0;'    Memorisation: gear ratio nul\nENDIF;ENDIF;ENDIF;ENDIF\n'\n' Boucle de mise a jour du bit Axe_Maitre_Mode_Gearing\n#MAJ_GR\niGr=0;iGr8=8;'     Index de la boucle GR (pointeur d'esclaves)\n#GRLOOP1\n GrTemp[iGr]=0;iGr=iGr+1;iGr8=iGr8+1\nJP#GRLOOP1,iGr<8;'    Iteration suivante\n'\niGr=0;iGr8=8;'     Index de la boucle GR (pointeur d'esclaves)\n#GRLOOP2\n GrMaster=GrTemp[iGr8]\n IF((0<=GrMaster)&(GrMaster<=7));' Si iGr est esclave\n  GrTemp[GrMaster]=$8000\n ENDIF\n iGr=iGr+1;iGr8=iGr8+1\nJP#GRLOOP2,iGr<8;'    Iteration suivante\n'\niGr=0;iGr8=8;'     Index de la boucle GR (pointeur d'esclaves)\n#GRLOOP3\n Stat[iGr]=(Stat[iGr]&@COM[$8000])|GrTemp[iGr]\n iGr=iGr+1;iGr8=iGr8+1\nJP#GRLOOP3,iGr<8;'    Iteration suivante\nEN\n'\n'=============== Execution des commandes Groupees ===============\n#GRP_CMD\n'\nJS#GETAXES,(GrpAxes<>OldGrpAx)\nJP#GRP_END,(gAx1<0);'   Sortie sur erreur\n'Si Mouvement autorise au device\nIF((Stat[gAx1]&$40)&(Stat[gAx2]&$40)&(Stat[gAx3]&$40)&(Stat[gAx4]&$40))\n JP#GRPCMST,(GrpCmd&1)\n JP#GRPCMJG,(GrpCmd&6)\n JP#GRPCMPA,(GrpCmd&8)\nENDIF\n'Si On/Off autorise au device\nIF((Stat[gAx1]&$20)&(Stat[gAx2]&$20)&(Stat[gAx3]&$20)&(Stat[gAx4]&$20))\n IF(GrpCmd&32);SH gStr;ENDIF\n IF(GrpCmd&64);MO gStr;ENDIF\nENDIF\n#GRP_END\nGrpCmd=0\nEN\n'\n'=========== Commande Groupee de Stop ===========\n#GRPCMST\nIF(_XQ1>0);'    Si la tache de prise de ref est executee,\n IF((gAx1=iPom)|(gAx2=iPom)|(gAx3=iPom)|(gAx4=iPom))\n  HX1;'     Arret tache de prise de ref\n  Stat[iPom]=((Stat[iPom]|$880)&@COM[$300])\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Prise_Ref_en_cours = 0 ($200)\n'       MAJ bit Echec_Prise_Ref = 1  ($800)\n  PosStat[iPom8]=0;'  Pas de Prise d'origine sur butee en cours\n ENDIF\nENDIF\nIF(_XQ2>0);'    Si la tache de correction d'erreur est executee,\n Stat[gAx1]=Stat[gAx1]&@COM[$1000];' MAJ bit Attente_de_correction = 0 ($1000)\n Stat[gAx2]=Stat[gAx2]&@COM[$1000]\n Stat[gAx3]=Stat[gAx3]&@COM[$1000]\n Stat[gAx4]=Stat[gAx4]&@COM[$1000]\n IF((gAx1=iCO)|(gAx2=iCO)|(gAx3=iCO)|(gAx4=iCO));'Si axe en cours de correc\n  HX2;'      Arret de la correction,\n  XQ#CORCHK,2;'    Controle des autres axes en erreur de correction,\n ENDIF\n NbRetry[gAx18]=NbRetry[gAx1];NbRetry[gAx28]=NbRetry[gAx2];' stop reessais dyn\n NbRetry[gAx38]=NbRetry[gAx3];NbRetry[gAx48]=NbRetry[gAx4]\n SP~e=spSave;'    Restauration de la vitesse avant correction\nENDIF\nST gStr;'      Arret des axes\nSpBackup[gAx18]=0;SpBackup[gAx28]=0;' Mode JOG off\nSpBackup[gAx38]=0;SpBackup[gAx48]=0\nPosStat[gAx1]=0;PosStat[gAx2]=0;'  Pas de positionnement en cours\nPosStat[gAx3]=0;PosStat[gAx4]=0\nStat[gAx1]=(Stat[gAx1]|$80)&@COM[$1100];Stat[gAx2]=(Stat[gAx2]|$80)&@COM[$1100]\nStat[gAx3]=(Stat[gAx3]|$80)&@COM[$1100];Stat[gAx4]=(Stat[gAx4]|$80)&@COM[$1100]\n'       MAJ bit Positionnement_termine=1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Attente_de_correction = 0 ($1000)\nJP#GRP_END\nEN\n'\n'============ Commande Groupee de Jog ============\n#GRPCMJG\nJgSign=(GrpCmd&2>0)-(GrpCmd&4>0);'  Calcul du signe du Jog\n'\n~f=gAx1;SpBackup[gAx18]=_SP~f*JgSign;JG~f=SpBackup[gAx18];' Commande mouvement\n' Si STEPPER avec CODEUR, definition position moteur selon codeur\nIF((@ABS[_MT~f]<>1)&(Stat[gAx1]&$2>0));DP~f=@RND[_TP~f/_YC~f*_YA~f*_YB~f];ENDIF\n'\n~f=gAx2;SpBackup[gAx28]=_SP~f*JgSign;JG~f=SpBackup[gAx28];' Commande mouvement\n' Si STEPPER avec CODEUR, definition position moteur selon codeur\nIF((@ABS[_MT~f]<>1)&(Stat[gAx2]&$2>0));DP~f=@RND[_TP~f/_YC~f*_YA~f*_YB~f];ENDIF\n'\n~f=gAx3;SpBackup[gAx38]=_SP~f*JgSign;JG~f=SpBackup[gAx38];' Commande mouvement\n' Si STEPPER avec CODEUR, definition position moteur selon codeur\nIF((@ABS[_MT~f]<>1)&(Stat[gAx3]&$2>0));DP~f=@RND[_TP~f/_YC~f*_YA~f*_YB~f];ENDIF\n'\n~f=gAx4;SpBackup[gAx48]=_SP~f*JgSign;JG~f=SpBackup[gAx48];' Commande mouvement\n' Si STEPPER avec CODEUR, definition position moteur selon codeur\nIF((@ABS[_MT~f]<>1)&(Stat[gAx4]&$2>0));DP~f=@RND[_TP~f/_YC~f*_YA~f*_YB~f];ENDIF\n'\nStat[gAx1]=(Stat[gAx1]&@COM[$2180]);Stat[gAx2]=(Stat[gAx2]&@COM[$2180])\nStat[gAx3]=(Stat[gAx3]&@COM[$2180]);Stat[gAx4]=(Stat[gAx4]&@COM[$2180])\n'       MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Erreur_de_poursuite = 0 ($2000)\nNbRetry[gAx18]=0;NbRetry[gAx28]=0;'  Initialisation nombre reessais dynamiques\nNbRetry[gAx38]=0;NbRetry[gAx48]=0\nBG gStr;'      Execution du mouvement groupe\nJP#GRP_END\nEN\n'\n'===== Commande Groupee de Positionnement =====\n#GRPCMPA\nStat[gAx1]=(Stat[gAx1]&@COM[$2180]);Stat[gAx2]=(Stat[gAx2]&@COM[$2180])\nStat[gAx3]=(Stat[gAx3]&@COM[$2180]);Stat[gAx4]=(Stat[gAx4]&@COM[$2180])\n'        MAJ bit Positionnement_termine = 0 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'        MAJ bit Erreur_de_poursuite = 0 ($2000)\niGrp=gAx1;JS#GRP_PA;'     Definition du positionnement Axe 1\niGrp=gAx2;JS#GRP_PA,(gAx2>gAx1);'   Definition du positionnement Axe 2\niGrp=gAx3;JS#GRP_PA,(gAx3>gAx1);'   Definition du positionnement Axe 3\niGrp=gAx4;JS#GRP_PA,(gAx4>gAx1);'   Definition du positionnement Axe 4\n'\nBG gStr;'       Execution du mouvement groupe\nPos[gAx18]=$7FFFFFFF;Pos[gAx28]=$7FFFFFFF;' Init derniere erreur de position\nPos[gAx38]=$7FFFFFFF;Pos[gAx48]=$7FFFFFFF\nNbRetry[gAx18]=0;NbRetry[gAx28]=0;'   Init nombre reessais dynamiques\nNbRetry[gAx38]=0;NbRetry[gAx48]=0\nNbRetry[gAx116]=0;NbRetry[gAx216]=0;'  Init nombre de reessais statiques\nNbRetry[gAx316]=0;NbRetry[gAx416]=0\nSpBackup[gAx18]=0;SpBackup[gAx28]=0;'  Mode JOG off\nSpBackup[gAx38]=0;SpBackup[gAx48]=0\nJP#GRP_END\nEN\n'\n'Definition du positionnement de chaque axe\n#GRP_PA\n~f=iGrp\n' Si STEPPER avec CODEUR, definition position moteur selon codeur\nIF((@ABS[_MT~f]<>1)&(Stat[iGrp]&$2>0));DP~f=@RND[_TP~f/_YC~f*_YA~f*_YB~f];ENDIF\nIF(_SP~f<SpMini);SP~f=SpMini;ENDIF;'  Verification des vitesses trop faibles\nActualPa=_PA~f;SpBackup[iGrp]=_SP~f;'  Recuperation de la position et vitesse\n'Gestion du Backlash\nIF(((Bck[iGrp]/@ABS[Bck[iGrp]])*(ActualPa-Pos[iGrp]))>0)\n PosStat[iGrp]=3;PA~f=(Pos[iGrp]-Bck[iGrp]);' Positionnement avec Backlash\nELSE;'        Positionnement sans Backlash\n PosStat[iGrp]=2;PA~f=@RND[(@RND[Pos[iGrp]]-ActualPa)*Percent[iGrp]]+ActualPa\nENDIF\nEN\n'\n'===== Routine de conversion du pointeur d'axes binaire en pointeur ASCII =====\n#GETAXES\niGrp=0;jGrp=0;bitGrp=1\nGrpAx[0]=0;GrpAx[1]=0;GrpAx[2]=0;GrpAx[3]=0;' Initialisation pointeurs ASCII\n#GETAXL\n JP#GETAXO1,(jGrp>3);'    Sortie sur saturation string (4 char)\n JP#GETAXO2,(iGrp>7);'    Sortie sur dernier axe\n IF(bitGrp&GrpAxes)\n  GrpAx[jGrp]=iGrp+65;jGrp=jGrp+1;'  MaJ pointeur ASCII\n ENDIF\n iGrp=iGrp+1;bitGrp=bitGrp*2\nJP#GETAXL\n#GETAXO2\n GrpAx[jGrp]=GrpAx[0];jGrp=jGrp+1\nJP#GETAXO2,(jGrp<4)\n#GETAXO1\n'\n'Mise en forme de la chaine de caractere de pointage du Groupe\nIF(GrpAx[0])\n gStr=GrpAx[0]*$100+GrpAx[1]*$100+GrpAx[2]*$100+GrpAx[3]\n gAx1=GrpAx[0]-65;gAx2=GrpAx[1]-65;gAx3=GrpAx[2]-65;gAx4=GrpAx[3]-65\n gAx18=gAx1+8;gAx28=gAx2+8;gAx38=gAx3+8;gAx48=gAx4+8\n gAx116=gAx1+16;gAx216=gAx2+16;gAx316=gAx3+16;gAx416=gAx4+16\nELSE\n gStr=$4E000000;gAx1=-1;gAx2=-1;gAx3=-1;gAx4=-1;' Pointeur par defaut : axe N\nENDIF\nOldGrpAx=GrpAxes\nEN\n'\n'===== Controle du Positionnement Termine =====\n#POSCHK\nIF(PosStat[i]>1);'  Positionnement termine, debut stabilisation\n StabTime[i8]=TIME+StabTime[i];' Recuperation du temps fin de stabilisation\n PosStat[i]=1;'    Declaration: Positionnement en stabilisation\nELSE;'    Positionnement termine, stabilise\n IF(StabTime[i8]<=TIME);'  Si temporisation de stabilisation ecoulee,\n  IF((@ABS[_MT~a]<>1)&(Stat[i]&$2>0));' Si STEPPER avec CODEUR,\n   DP~a=@RND[(_TP~a/_YC~a)*_YA~a*_YB~a];' Definition pos moteur selon cod\n  ENDIF\n  ActuPaCh=_PA~a;'     Recuperation de la position moteur\n  JP#POS_OK,(@ABS[Pos[i]-ActuPaCh]<=Dbw[i]);' Si position dans la plage cible\n'  Si position actuelle hors de la plage cible\n  IF(Debug=1);'           !! DEBUG !!\n   CFS;MGPosErr Axis,~a,SC,_SC~a,RtrS,NbRetry[i16],RtrD,NbRetry[i8]\n  ENDIF\n  JP#POSSTOP,(_SC~a=4);'    Si le dernier mouvement a ete arrete par un Stop\n  JP#POS_LS,(_SC~a=2)|(_SC~a=3);'  Si dernier mouvement arrete par une butee\n  IF(@ABS[Pos[i]-ActuPaCh]>=Pos[i8]);' Si l'erreur de position diverge\n   NbRetry[i16]=NbRetry[i16]+1;'  Increment du nombre de reessais statiques\n   Stat[i]=Stat[i]|$2000;'   MAJ bit Erreur_de_poursuite = 1 ($2000)\n  ELSE;'     Si l'erreur de position converge vers 0\n   Stat[i]=Stat[i]|&@COM[$2000];' MAJ bit Erreur_de_poursuite = 0 ($2000)\n  ENDIF\n  Pos[i8]=@ABS[Pos[i]-ActuPaCh];' Mise en memoire de l'erreur de position\n  JP#POSRTRY,(NbRetry[i16]<NbRetry[i]);' Si nb essais statique pas excessif\n  JP#POSLAST,(NbRetry[i16]=NbRetry[i]);' Si c'est le dernier essai\n'  Si le nombre de reessais est excessif\n  PosStat[i]=0;'    Declaration: Pas de positionnement en cours\n  Stat[i]=Stat[i]|$2180;'   MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'        MAJ bit Erreur_de_poursuite = 1 ($2000)\n  SP~a=SpBackup[i];'   Restauration de la vitesse\n ENDIF\nENDIF\n'\nEN\n'\n'Si position dans la plage cible\n#POS_OK\n PosStat[i]=0;'    Declaration: Pas de positionnement en cours\n Stat[i]=((Stat[i]|$80)&@COM[$2100]);' On ne bouge pas\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Erreur_de_poursuite = 0 ($2000)\n SP~a=SpBackup[i];'   Restauration de la vitesse\nEN\n'\n'Si le dernier mouvement a ete arrete par un Stop\n#POSSTOP\n PosStat[i]=0;'    Declaration: Pas de positionnement en cours\n Stat[i]=Stat[i]|$80;'   MAJ bit Positionnement_termine = 1 ($80)\n SP~a=SpBackup[i];'   Restauration de la vitesse\nEN\n'\n'Si le dernier mouvement a ete arrete par une butee de fin de course\n#POS_LS\n PosStat[i]=0;'    Declaration: Pas de positionnement en cours\n Stat[i]=(Stat[i]|$180);'   MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 1 ($100)\n SP~a=SpBackup[i];'   Restauration de la vitesse\nEN\n'\n'Si le nombre de reessais statiques n'est pas excessif\n#POSRTRY\n IF(_SP~a<SpMini);SP~a=SpMini;ENDIF;'Verification des vitesses trop faibles\n IF(((Bck[i]/@ABS[Bck[i]])*(ActuPaCh-Pos[i]))>0)\n  PosStat[i]=3;'    Declaration: positionnement avec backlash en cours\n  PA~a=(Pos[i]-Bck[i]);BG~a;'  Positionnement avec Backlash\n ELSE;'     Si (Pd-Pa+Bck) n'est pas du signe de Bck,\n  PosStat[i]=2;'    Declaration: positionnement sans backlash en cours\n  PA~a=@RND[(@RND[Pos[i]]-ActuPaCh)*Percent[i]]+ActuPaCh;' Posinement simple\n  BG~a\n ENDIF\nEN\n'\n'Si c'est le dernier essai\n#POSLAST\n' Abandon si un Backlash est necessaire car le prochain essai sera divergent\n IF(((Bck[i]/@ABS[Bck[i]])*(ActuPaCh-Pos[i]))>0)\n  PosStat[i]=0;'    Declaration: Pas de positionnement en cours\n  Stat[i]=Stat[i]|$2180;'   MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'        MAJ bit Erreur_de_poursuite = 1 ($2000)\n  SP~a=SpBackup[i];'   Restauration de la vitesse\n ELSE;'     Si dernier essai en positionnement normal\n  IF(_SP~a<SpMini);SP~a=SpMini;ENDIF;'Verification des vitesses trop faibles\n  PosStat[i]=2;'    Declaration: positionnement sans backlash en cours\n  PA~a=@RND[(@RND[Pos[i]]-ActuPaCh)*Percent[i]]+ActuPaCh;BG~a;' Positionnement\n ENDIF\nEN\n'\n'===== Controle d'erreur de poursuite, mode Stepper Maintenance Position =====\n#MOVCHK\nIF(@ABS[(_TP~a/_YC~a)*_YA~a*_YB~a-_TD~a]>_ER~a);' Si erreur de poursuite,\n'\n IF(Stat[i]&$200>0);' Si Prise d'Origine en cours,\n  HX1;'    Arret de la tache de POM sur erreur\n  Stat[i]=(Stat[i]|$2980)&@COM[$200]\n'      MAJ bit Positionnement_termine = 1 ($80)\n'      MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'      MAJ bit Echec_Prise_Ref = 1  ($800)\n'      MAJ bit Erreur_de_poursuite = 1 ($2000)\n'      MAJ bit Prise_Ref_en_cours = 0 ($200)\n  ST~a;'   Arret de l'axe\n  SpBackup[i]=0;'  Mode JOG off\n  PosStat[i]=0;'  Pas de positionnement en cours\n  PosStat[i8]=0;'  Pas de Prise d'origine sur butee en cours\n  SP~a=PomSpBck;'  Restauration de la vitesse avant prise d'origine\n ELSE;'   Si pas de Prise d'Origine en cours,\n  PosStat[i]=0;'  Declaration: pas de positionnement en cours\n'  Si MaintenancePos actif avec Correction active et ni Remote, ni Slit,\n  IF((Stat[i]&$C00C)=4)&((CpMp[i]&16)<>0)\n   IF(_XQ2<0);'  Si la tache de correction d'erreur n'est pas executee,\n    iCO=i;iCO8=i+8;iCO16=i+16;~e=~a;'Definition des pointeur pour la correction\n    XQ#PECORR,2;'  Execution de la tache de correction d'erreur\n   ELSE;'   Si la tache de correction d'erreur est executee,\n    ST~a;'   Arret de l'axe en erreur\n    Stat[i]=Stat[i]|$3000;' MAJ bit Attente_de_correction = 1 ($1000)\n'        MAJ bit Erreur_de_poursuite = 1 ($2000)\n   ENDIF\n  ELSE;'   Si MaintenancePos inactif ou Remote ou Slit,\n   IF(GrTemp[i8]>=0);'  Si l'axe i est esclave, arret du maitre\n    valTildA=~a;'   Mise en memoire de l'axe pointe par ~a\n    IF(GrTemp[i8]=8);'  Si N est l'axe maitre (axe virtuel),\n     ~a=10;'    pointeur de l'axe virtuel\n    ELSE\n     moMaster=(GrTemp[i8]&$0F);' recherche du maitre de l'axe i\n     moMaste8=moMaster+8\n     ~a=moMaster;'    pointeur de l'axe maitre\n     SpBackup[moMaste8]=0;'   Mode JOG off\n     PosStat[moMaster]=0;'   Pas de positionnement en cours\n     Stat[moMaster]=(Stat[moMaster]|$180);'MAJ Positionnement_termine=1 ($80)\n'             MAJ Pos_termine_sur_erreur=1 ($100)\n    ENDIF\n    ST~a;'    Arret de l'axe maitre\n    ~a=valTildA;'   Restauration de l'axe pointe par ~a (esclave)\n'    Arret de la synchronisation maitre-esclave et MAJ des bits\n    GR~a=0;'     Gear Ratio Nul (Pas d'axe Maitre)\n    ST~a;'     Arret du Jog nul de l'axe esclave\n    SP~a=SpBackup[i];'   Restauration de la vitesse de l'axe esclave\n    Stat[i]=(Stat[i]|$1E0)&@COM[$4000]\n'          MaJ bit Axe_Esclave = 0   ($4000)\n'          MaJ bit OnOff_Autorise = 1  ($20)\n'          MaJ bit Mvmt_Autorise = 1  ($40)\n'          MAJ bit Positionnement_termine = 1 ($80)\n'          MAJ bit Pos_termine_sur_erreur = 1 ($100)\n    GrTemp[i8]=-1;'    Memorisation: pas d'axe maitre\n    GrTemp[i16]=0;'    Memorisation: gear ratio nul\n    JS#MAJ_GR;'     MAJ des bits de Gearing\n   ENDIF\n   ST~a;'    Arret de l'axe\n   Stat[i]=(Stat[i]|$2180)&@COM[$1000]\n'        MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'        MAJ bit Attente_de_correction = 0 ($1000)\n'        MAJ bit Erreur_de_poursuite = 1 ($2000)\n  ENDIF\n ENDIF\n'\nENDIF\n'\nEN\n'\n'===== Controle de CpMp - Presence Codeur et Maintenance Position =====\n#CPMP\n' Si demande de desactivation du mode Remote et si telecommande active\nJS#STOPMV,(((CpMp[i]&$8)=0)&(EnRem[i]=1));' Appel de routine d'arret\n'MAJ bits Codeur_Present ($2) et Maintenance_Position ($4)\nStat[i]=(Stat[i]&@COM[$6])|(((CpMp[i]&$3)>0)*2)|(CpMp[i]&$4)\n'Si codeur absolu, alors axe automatiqmt initialise (etat init des devices)\nIF((CpMp[i]&$2)>0);Stat[i]=Stat[i]|$400;ENDIF\n'MAJ bit Attributs initialises (si les bits 15 ou 31 sont a 1) ($10000)\nIF((CpMp[i]&$FFFF8000)<>0);Stat[i]=Stat[i]|$10000;ENDIF\nCpMp[i8]=CpMp[i];'     Mise en memoire de CpMp[i]\nEN\n'\n'===== Routine Remote - Pilotage des motorisations avec une telecommande =====\n#REMOTE\nIF(i>3); iRem=i+5; ELSE; iRem=i+1; ENDIF;'Decalage de l'index des INPUTS\n'\nIF(@IN[iRem]=1);'  Si l'entree iRem est a 1, telecommande innactive\n JS#STOPMV,(EnRem[i8]=1);'  Appel de routine d'arret si axe en mouvement\nELSE;'   Si l'entree iRem est a 0, telecommande active\n Stat[i]=(Stat[i]|$8)&@COM[$1E0];' MaJ bit Telecommande Active = 1  ($8)\n'       MaJ bit OnOff_Autorise = 0  ($20)\n'       MaJ bit Mvmt_Autorise = 0  ($40)\n'       MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n IF(EnRem[i8]=0);' Si l'axe est a l'arret\n  JS#STARTMV;' Appel de la routine de demarrage de l'axe\n ELSE;'   Si l'axe est en mouvement\n  JS#MOVE;'  Appel de la routine de mise a jour de la vitesse de l'axe\n ENDIF\nENDIF\nOB(2*i+1),(_LR~a=0)|(_LF~a=0);' Affichage de l'etat des fins de course\nEN\n' ***** Start Move *****\n#STARTMV\nST~a;'   Arret de l'axe\nSpBackup[i8]=0;'  Mode JOG off\nPosStat[i]=0;'  Pas de positionnement en cours\nIF(_MO~a);SH~a;ENDIF;' Demarrage de l'axe s'il ne l'est pas\nSpBackup[i16]=_SP~a;' Recuperation de la valeur de la vitesse\nJG~a=0; BG~a;'  Initialisation d'un mouvement a vitesse nulle\nEnRem[i8]=1;'  Declaration de l'etat de l'axe : Ready\nSB(2*i+2);'   Led Ready : axe ON\nEN\n' ******** Move ********\n#MOVE\nana=@AN[i+1];'  Memorisation de l'entree Analogique de l'axe i+1\n'Lancement du Jog en fonction de la consigne analogique\nJP#NEG_LOW,((ana>2)&(ana<3.5));'  Vitesse Lente,  sens Negatif\nJP#NEG_HIG,((ana>4)&(ana<5.5));'  Vitesse Rapide, sens Negatif\nJP#POS_LOW,((ana>6)&(ana<7.5));'  Vitesse Lente,  sens Positif\nJP#POS_HIG,((ana>8)&(ana<9.7));'  Vitesse Rapide, sens Positif\nJG~a=0;'      Vitesse nulle\n'Redemarrage de l'axe s'il est arrete et si l'etat des butees le permet\nIF((_TS~a&$A8)=$8);BG~a;ENDIF\nEN\n'Vitesse Lente, sens Negatif\n#NEG_LOW\nJG~a=-SpBackup[i16]/5\nIF((_TS~a&$A4)=$4);BG~a;ENDIF\nEN\n'Vitesse Rapide, sens Negatif\n#NEG_HIG\nJG~a=-SpBackup[i16]\nIF((_TS~a&$A4)=$4);BG~a;ENDIF\nEN\n'Vitesse Lente, sens Positif\n#POS_LOW\nJG~a=SpBackup[i16]/5\nIF((_TS~a&$A8)=$8);BG~a;ENDIF\nEN\n'Vitesse Rapide, sens Positif\n#POS_HIG\nJG~a=SpBackup[i16]\nIF((_TS~a&$A8)=$8);BG~a;ENDIF\nEN\n' ****** Stop Move *****\n#STOPMV\nST~a;'   Arret de l'axe\nIF(EnRem[i8]);'  Si telecommande active,\n SP~a=SpBackup[i16];' Restauration de la valeur de la vitesse\nENDIF\nEnRem[i8]=0;'  Declaration de l'etat de l'axe : OFF\nCB(2*i+2);'   Led Ready : axe OFF\nStat[i]=(Stat[i]|$E0)&@COM[$108];' MaJ bit Telecommande Active = 0  ($8)\n'      MaJ bit OnOff_Autorise = 1  ($20)\n'      MaJ bit Mvmt_Autorise = 1  ($40)\n'      MAJ bit Positionnement_termine = 1 ($80)\n'      MAJ bit Pos_termine_sur_erreur = 0 ($100)\nEN\n'\n'======= Routine de traitement des Fins de courses =======\n#LIMSWI\niLS=0;iLS8=8;iLS16=16;~d=0;' Initialisation pointeur de tableau et d'axe\n'\n' Boucle de detection des axes iLS en Butee\n#LSLOOP\n JP#LS_NEXT,(((_SC~d=2)|(_SC~d=3))=0);' Si butee inactive, passage a suivante\n JS#LSDEBUG,(Debug=1);'    DEBUG\n JP#LSINPOM,(Stat[iLS]&$200>0);'  Si Prise d'Origine en cours\n JP#LS_STD;'      Traitement des butees classiques\n'\n#LS_NEXT\n' Increment des pointeurs de tableau et d'axe\n iLS=iLS+1;iLS8=iLS8+1;iLS16=iLS16+1;~d=iLS\nJP#LSLOOP,(iLS<8);' Controle des 8 axes\n'\nRE0;'    Retour d'interruption #LIMSWI\n'\n' Traitement des butees classiques\n#LS_STD\nDcLimBck=_DC~d;'    Mise en memoire de la deceleration\n ST~d;'     Arret de l'axe\n IF(_DC~d<DcLimSwi);DC~d=DcLimSwi;ENDIF;' Augmentation des decels trop lentes\n IF(GrTemp[iLS8]>=0);'   Si l'axe iLS est esclave,\n  valTildD=~d;'    Mise en memoire de l'axe pointe par ~d\n  IF(GrTemp[iLS8]=8);'   Si N est l'axe maitre (axe virtuel),\n   ~d=10;'     pointeur de l'axe virtuel\n  ELSE\n   lsMaster=(GrTemp[iLS8]&$0F);'  recherche du maitre de l'axe iLS\n   lsMaste8=lsMaster+8\n   ~d=lsMaster;'    pointeur de l'axe maitre\n   SpBackup[lsMaste8]=0;'   Mode JOG off\n   PosStat[lsMaster]=0;'   Pas de positionnement en cours\n   Stat[lsMaster]=(Stat[lsMaster]|$180);'MAJ bit Positionement_termine=1 ($80)\n'           MAJ bit Pos_termine_sur_erreur=1 ($100)\n  ENDIF\n  ST~d;'     Arret de l'axe maitre\n  ~d=valTildD;'    Restauration de l'axe pointe par ~d\n'  Arret de la synchronisation maitre-esclave et MAJ des bits\n  GR~d=0;'     Gear Ratio Nul (Pas d'axe Maitre)\n  ST~d;'     Arret du Jog nul de l'axe esclave\n  SP~d=SpBackup[iLS];'   Restauration de la vitesse de l'axe esclave\n  Stat[iLS]=(Stat[iLS]|$1E0)&@COM[$4000]\n'        MaJ bit Axe_Esclave = 0   ($4000)\n'        MaJ bit OnOff_Autorise = 1  ($20)\n'        MaJ bit Mvmt_Autorise = 1  ($40)\n'        MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 1 ($100)\n  GrTemp[iLS8]=-1;'    Memorisation: pas d'axe maitre\n  GrTemp[iLS16]=0;'    Memorisation: gear ratio nul\n  JS#MAJ_GR;'     MAJ des bits de Gearing\n ENDIF\n IF(_XQ2>=0);'   Si la tache de correction d'erreur est executee,\n  IF(iLS=iCO)\n   NbRetry[iLS8]=NbRetry[iLS];'  Plus de reessais possibles\n   SP~d=spSave;'    Restauration de la vitesse avant correction\n  ENDIF\n ENDIF\n Stat[iLS]=Stat[iLS]|$180;' MAJ bit Positionnement_termine = 1 ($80)\n'      MAJ bit Pos_termine_sur_erreur = 1 ($100)\n SpBackup[iLS8]=0;'  Mode JOG off\n PosStat[iLS]=0;'   Pas de positionnement en cours\nIF(CmdHvOk);'               Si la commande HV est supportee,\n DC~d=DcOld[iLS];'  Set deceleration to old value\n ELSE\n DC~d=DcLimBck;'   Restauration de la deceleration\nENDIF\nJP#LS_NEXT\nEN\n'\n' Traitement des butees actives en cours de prise d'origine\n#LSINPOM\n IF(PosStat[iLS8]=0);'   Si prise d'origine sur home ou index\n  DcLimBck=_DC~d;'    Mise en memoire de la deceleration\n  IF(_DC~d<DcLimSwi);DC~d=DcLimSwi;ENDIF;' Augmentation des decels trop lentes\n  HX1;'      Arret de la tache de POM sur erreur\n  ST~d;'     Arret de l'axe\n  Stat[iLS]=((Stat[iLS]&@COM[$606])|$980)|(((CpMp[iLS]&3)>0)*2)|(CpMp[iLS]&4)\n'        MAJ bit Codeur_Present   ($2)\n'        MAJ bit Maintenance_Position  ($4)\n'        MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'        MAJ bit Prise_Ref_en_cours= 0  ($200)\n'        MAJ bit Prise_Ref_Faite = 0  ($400)\n'        MAJ bit Echec_Prise_Ref = 1  ($800)\n  CpMp[iLS8]=CpMp[iLS];'   Mise en memoire de CpMp[iLS]\n  iFh=nbFh;iFi=nbFi;'   Arret des recherches de home et d'index\n  SpBackup[iLS8]=0;'   Mode JOG off\n  PosStat[iLS]=0;'    Pas de positionnement en cours\nIF(CmdHvOk);'               Si la commande HV est supportee,\n DC~d=DcOld[iLS];'  Set deceleration to old value\n ELSE\n DC~d=DcLimBck;'   Restauration de la deceleration\nENDIF\n  SP~d=PomSpBck;'    Restauration de la vitesse avant prise d'origine\n ENDIF;'     Pas d'erreur si prise d'origine sur butee + ou -,\nJP#LS_NEXT\nEN\n'\n#LSDEBUG\nCFS;MGLimSw Axis,~d,LineT0,_XQ0,LineT1,_XQ1;'!! DEBUG !!\nEN\n'=========================================================\n'\n'========== Gestion_des_commandes_erronnees ==========\n#CMDERR\n'\nIF(Debug=1)\n CFS;MGCMD Error,_TC,Line,_ED2,Thread,_ED1;'!! SEULEMENT POUR DEBUG !!\nENDIF\n'\nJP#CMDTR0,(_ED1=0);' Si le thread 0 est en erreur\nJP#CMDTR1,(_ED1=1);' Si le thread 1 Prise d'origine est en erreur\nJP#CMDTR2,(_ED1=2);' Si le thread 2 Correction d'erreur est en erreur\nJP#CMDTRN;'   Si un autre thread est en erreur\nEN\n'\n#CMDTR0\nIF((_TC=20)|(_TC=21)|(_TC=22));' SI Begin_not_valid_with_motor_off (20)\n'      OU Begin_not_valid_while_running (21)\n'      OU Begin_not_possible_due_to_Limit_Switch (22)\n IF(((_LR~a&_LF~a)=0)|(_MO~a));' Si une butee est active ou le moteur est Off\n  Stat[i]=(Stat[i]|$180);'  MAJ bit Positionnement_termine=1 ($80)\n'        MAJ bit Pos_termine_sur_erreur=1 ($100)\n  PosStat[i]=0;'    Pas de positionnement en cours\n  IF(GrTemp[i8]>=0);'  Si l'axe i est esclave, arret du maitre\n   valTildA=~a;'   Mise en memoire de l'axe pointe par ~a\n   IF(GrTemp[i8]=8);'  Si N est l'axe maitre (axe virtuel),\n    ~a=10;'    pointeur de l'axe virtuel\n   ELSE\n    erMaster=(GrTemp[i8]&$0F);' recherche du maitre de l'axe i\n    erMaste8=erMaster+8\n    ~a=erMaster;'    pointeur de l'axe maitre\n    SpBackup[erMaste8]=0;'   Mode JOG off\n    PosStat[erMaster]=0;'   Pas de positionnement en cours\n    Stat[erMaster]=(Stat[erMaster]|$180);'MAJ Positionnement_termine=1 ($80)\n'            MAJ Pos_termine_sur_erreur=1 ($100)\n   ENDIF\n   ST~a;'    Arret de l'axe maitre\n   ~a=valTildA;'   Restauration de l'axe pointe par ~a (esclave)\n'   Arret de la synchronisation maitre-esclave et MAJ des bits\n   GR~a=0;'     Gear Ratio Nul (Pas d'axe Maitre)\n   ST~a;'     Arret du Jog nul de l'axe esclave\n   SP~a=SpBackup[i];'   Restauration de la vitesse de l'axe esclave\n   Stat[i]=(Stat[i]|$1E0)&@COM[$4000]\n'         MaJ bit Axe_Esclave = 0   ($4000)\n'         MaJ bit OnOff_Autorise = 1  ($20)\n'         MaJ bit Mvmt_Autorise = 1  ($40)\n'         MAJ bit Positionnement_termine = 1 ($80)\n'         MAJ bit Pos_termine_sur_erreur = 1 ($100)\n   GrTemp[i8]=-1;'    Memorisation: pas d'axe maitre\n   GrTemp[i16]=0;'    Memorisation: gear ratio nul\n   JS#MAJ_GR;'     MAJ des bits de Gearing\n  ENDIF\n ENDIF\n IF(_XQ_ED1<0);' Si le thread de l'erreur n'est plus execute\n  XQ_ED3,_ED1,1;' Execute commande suivante dans le thread de l'erreur\n ENDIF\nENDIF\nEN\n'\n#CMDTR1\nStat[iPom]=((Stat[iPom]&@COM[$606])|$880)|(((CpMp[iPom]&3)>0)*2)|(CpMp[iPom]&4)\n'     MAJ bit Codeur_Present   ($2)\n'     MAJ bit Maintenance_Position  ($4)\n'     MAJ bit Positionnement_termine = 1 ($80)\n'     MAJ bit Prise_Ref_en_cours= 0  ($200)\n'     MAJ bit Prise_Ref_Faite = 0  ($400)\n'     MAJ bit Echec_Prise_Ref = 1  ($800)\nCpMp[iPom8]=CpMp[iPom];' Mise en memoire de CpMp[iPom]\nST~b;'    Arret de l'axe\nSpBackup[iPom8]=0;'  Mode JOG off\nPosStat[iPom]=0;'   Pas de positionnement en cours\nPosStat[iPom8]=0;'  Pas de Prise d'origine sur butee en cours\nSP~b=PomSpBck;'   Restauration de la vitesse avant prise d'origine\nEN\n'\n#CMDTR2\nStat[iCO]=(Stat[iCO]|$180)\n'     MAJ bit Positionnement_termine=1 ($80)\n'     MAJ bit Pos_termine_sur_erreur=1 ($100)\nST~e;'    Arret de l'axe en erreur\nEN\n'\n#CMDTRN\nIF((_TC=20)|(_TC=21)|(_TC=22));' SI Begin_not_valid_with_motor_off (20)\n'      OU Begin_not_valid_while_running (21)\n'      OU Begin_not_possible_due_to_Limit_Switch (22)\n' Si une butee est active ou le moteur est Off\n' MAJ bit Positionnement_termine=1 ($80)\n' MAJ bit Pos_termine_sur_erreur=1 ($100)\n' et declaration : pas de positionnement en cours\n IF((LastAxis=0)&((_LRA&_LFA=0)|_MOA));Stat[0]=Stat[0]|$180;PosStat[0]=0;ENDIF\n IF((LastAxis=1)&((_LRB&_LFB=0)|_MOB));Stat[1]=Stat[1]|$180;PosStat[1]=0;ENDIF\n IF((LastAxis=2)&((_LRC&_LFC=0)|_MOC));Stat[2]=Stat[2]|$180;PosStat[2]=0;ENDIF\n IF((LastAxis=3)&((_LRD&_LFD=0)|_MOD));Stat[3]=Stat[3]|$180;PosStat[3]=0;ENDIF\n IF((LastAxis=4)&((_LRE&_LFE=0)|_MOE));Stat[4]=Stat[4]|$180;PosStat[4]=0;ENDIF\n IF((LastAxis=5)&((_LRF&_LFF=0)|_MOF));Stat[5]=Stat[5]|$180;PosStat[5]=0;ENDIF\n IF((LastAxis=6)&((_LRG&_LFG=0)|_MOG));Stat[6]=Stat[6]|$180;PosStat[6]=0;ENDIF\n IF((LastAxis=7)&((_LRH&_LFH=0)|_MOH));Stat[7]=Stat[7]|$180;PosStat[7]=0;ENDIF\n'\n XQ_ED3,_ED1,1;' Execute commande suivante dans le thread de l'erreur\nENDIF\nEN\n'\n'===== Routine de traitement des erreurs de position =====\n#POSERR\niPE=0;iPE8=8;iPE16=16;~c=0;'  Initialisation pointeurs de tableau et d'axe\n'\n' Boucle de detection des axes iPE en Erreur de Position\n#PELOOP\n'\nIF(_TS~c&64>0);' Si l'axe ~c est en erreur de position,\n'\n IF(Stat[iPE]&$200>0);'  Si Prise d'Origine en cours,\n  HX1;'      Arret de la tache de POM sur erreur\n  Stat[iPE]=((Stat[iPE]&@COM[$606])|$2980)|(((CpMp[iPE]&3)>0)*2)|(CpMp[iPE]&4)\n'       MAJ bit Codeur_Present   ($2)\n'       MAJ bit Maintenance_Position  ($4)\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'       MAJ bit Prise_Ref_en_cours= 0  ($200)\n'       MAJ bit Prise_Ref_Faite = 0  ($400)\n'       MAJ bit Echec_Prise_Ref = 1  ($800)\n'       MAJ bit Erreur_de_poursuite = 1 ($2000)\n  CpMp[iPE8]=CpMp[iPE];' Mise en memoire de CpMp[iPE]\n  ST~c;'    Arret de l'axe\n  SpBackup[iPE8]=0;'  Mode JOG off\n  PosStat[iPE]=0;'   Pas de positionnement en cours\n  PosStat[iPE8]=0;'   Pas de Prise d'origine sur butee en cours\n  SP~c=PomSpBck;'   Restauration de la vitesse avant prise d'origine\n'\n ELSE;'    Si pas de Prise d'Origine en cours,\n  PosStat[iPE]=0;'   Declaration: pas de positionnement en cours\n  IF((Stat[iPE]&$C004)=4);' Si MaintenancePos actif et ni Remote ni Slit,\n   IF(NbRetry[iPE8]<NbRetry[iPE])\n    IF(_XQ2<0);'   Si la tache de correction d'erreur n'est pas executee,\n     iCO=iPE;iCO8=iPE8;iCO16=iPE16;~e=~c;'Def. des pointeur de correction\n     XQ#PECORR,2;'  Execution de la tache de correction d'erreur\n    ELSE;'    Si la tache de correction d'erreur est executee,\n     ST~c;'    Arret de l'axe en erreur\n     Stat[iPE]=Stat[iPE]|$3000;' MAJ bit Attente_de_correction = 1 ($1000)\n'          MAJ bit Erreur_de_poursuite = 1 ($2000)\n    ENDIF\n   ENDIF\n  ELSE;'    Si MaintenancePos inactif ou Remote ou Slit,\n   IF(GrTemp[iPE8]>=0);'  Si l'axe iPE est esclave, arret du maitre\n    valTildC=~c;'    Mise en memoire de l'axe pointe par ~c\n    IF(GrTemp[iPE8]=8);'   Si N est l'axe maitre (axe virtuel),\n     ~c=10;'     pointeur de l'axe virtuel\n    ELSE\n     PeMaster=(GrTemp[iPE8]&$0F);'  recherche du maitre de l'axe iPE\n     PeMaste8=PeMaster+8\n     ~c=PeMaster;'    pointeur de l'axe maitre\n     SpBackup[PeMaste8]=0;'   Mode JOG off\n     PosStat[PeMaster]=0;'   Pas de positionnement en cours\n     Stat[PeMaster]=(Stat[PeMaster]|$180);'MAJ bit Posinment_termine=1 ($80)\n'             MAJ bit Pos_termine_sur_erreur=1 ($100)\n    ENDIF\n    ST~c;'     Arret de l'axe maitre\n    ~c=valTildC;'    Restauration de l'axe pointe par ~c\n'    Arret de la synchronisation maitre-esclave et MAJ des bits\n    GR~c=0;'     Gear Ratio Nul (Pas d'axe Maitre)\n    ST~c;'     Arret du Jog nul de l'axe esclave\n    SP~c=SpBackup[iPE];'   Restauration de la vitesse de l'axe esclave\n    Stat[iPE]=(Stat[iPE]|$1E0)&@COM[$4000]\n'          MaJ bit Axe_Esclave = 0   ($4000)\n'          MaJ bit OnOff_Autorise = 1  ($20)\n'          MaJ bit Mvmt_Autorise = 1  ($40)\n'          MAJ bit Positionnement_termine = 1 ($80)\n'          MAJ bit Pos_termine_sur_erreur = 1 ($100)\n    GrTemp[iPE8]=-1;'    Memorisation: pas d'axe maitre\n    GrTemp[iPE16]=0;'    Memorisation: gear ratio nul\n    JS#MAJ_GR;'     MAJ des bits de Gearing\n   ENDIF\n   Stat[iPE]=Stat[iPE]|$2180;' MAJ bit Positionnement_termine = 1 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'        MAJ bit Erreur_de_poursuite = 1 ($2000)\n  ENDIF\n ENDIF\n' Si SERVO en erreur de position, etat Off et vitesse reduite,\n IF((@ABS[_MT~c]=1)&(@ABS[_TE~c]>=_ER~c)&(_MO~c)&(@ABS[_TV~c]<100))\n  DP~c=_TP~c;'   Definition position commandee selon codeur (RAZ de l'erreur)\n  Stat[iPE]=Stat[iPE]|$2000;' MAJ bit Erreur_de_poursuite = 1 ($2000)\n ENDIF\nENDIF\n'Increment pointeur de tableau et pointeur d'axe\niPE=iPE+1;iPE8=iPE8+1;iPE16=iPE16+1;~c=iPE\nJP#PELOOP,(iPE<8);'  Controle des 8 axes\nRE0;'     Retour d'interruption #POSERR\n'\n'=========== Tache de correction de l'erreur de position ============\n'\n#PECORR\nStat[iCO]=Stat[iCO]|$2000;' MAJ bit Erreur_de_poursuite = 1 ($2000)\nspSave=_SP~e;'   Sauvegarde de la vitesse actuelle\nSP~e=spSave/10;'   Vitesse de correction reduite\nIF(_SP~e<SpMini);SP~e=SpMini;ENDIF;'Verification des vitesses trop faibles\nST~e;MC~e;YR~e=0;'  Arret de l'axe en erreur\n#CORREC\n IF(NbRetry[iCO8]<NbRetry[iCO])\n  YR~e=_TD~e-@RND[(_TP~e/_YC~e)*_YA~e*_YB~e];' Correction d'erreur de position\n  MC~e;'    Attente de la fin du mouvement\n  WT StabTime[iCO];'  Attente de stabilisation\n ENDIF\n NbRetry[iCO8]=NbRetry[iCO8]+1;'On incremente le nombre de reessais dynamiques\n ErrPos=@RND[(_TP~e/_YC~e)*_YA~e*_YB~e-_TD~e];' Calcul de l'erreur de position\n IF(Debug=1)\n  CFS;MG Correction,ErrPos,axe,iCO,essai,NbRetry[iCO8];'!!! DEBUG !!!\n ENDIF\n 'Reessai si erreur excessive, nb essais ds tolerance et pas d'arret sur stop\nJP#CORREC,(@ABS[ErrPos]>_ER~e)&(NbRetry[iCO8]<NbRetry[iCO])&(_SC~e<>4)\nSP~e=spSave;'   Restauration de la vitesse sauvegardee\nJP#CORSTOP,(_SC~e=4);'  Si mouvement arrete par commande Stop\nJP#CORFAIL,((@ABS[ErrPos]>_ER~e)|(NbRetry[iCO8]>NbRetry[iCO]));' Si tjrs erreur\n'Si l'erreur est corrigee\nIF(SpBackup[iCO8]=0);'   Si le mode JOG est off,\n' on relance le positionnement\n IF((@ABS[_MT~e]<>1)&(Stat[iCO]&$2>0));' Si STEPPER avec CODEUR,\n  DP~e=@RND[(_TP~e/_YC~e)*_YA~e*_YB~e];' Def. position moteur selon codeur\n ENDIF\n ActuPaCo=_PA~e;'    Recuperation de la position moteur\n IF(@ABS[Pos[iCO]-ActuPaCo]<=Dbw[iCO]);' Si position actuelle dans plage cible\n  Stat[iCO]=((Stat[iCO]|$80)&@COM[$2100]);' On ne bouge pas\n'       MAJ bit Positionnement_termine = 1 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Erreur_de_poursuite = 0 ($2000)\n ELSE\n  Stat[iCO]=(Stat[iCO]&@COM[$2180]);' MAJ bit Positionnement_termine = 0 ($80)\n'        MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'        MAJ bit Erreur_de_poursuite = 0 ($2000)\n  ' Gestion du Backlash\n  ' (Pd-Pa+Bck) du signe de Bck ?\n  IF(((Bck[iCO]/@ABS[Bck[iCO]])*(ActuPaCo-Pos[iCO]))>0)\n   PosStat[iCO]=3;'   Declaration: positionnement avec backlash en cours\n   PA~e=(Pos[iCO]-Bck[iCO]);BG~e;' Positionnement avec Backlash\n  ELSE;'     Si (Pd-Pa+Bck) n'est pas du signe de Bck,\n   PosStat[iCO]=2;'   Declaration: positionnement sans backlash en cours\n   PA~e=@RND[(@RND[Pos[iCO]]-ActuPaCo)*Percent[iCO]]+ActuPaCo;BG~e;'Posinmnt\n  ENDIF\n  NbRetry[iCO16]=0;'   Initialisation nombre de reessais statiques nul\n  SpBackup[iCO8]=0;'   Mode JOG off\n ENDIF\nELSE;'    Si le mode JOG est on,\n' on relance le jog\n JG~e=SpBackup[iCO8];'   Commande du mouvement\n Stat[iCO]=(Stat[iCO]&@COM[$2180]);' MAJ bit Positionnement_termine = 0 ($80)\n'       MAJ bit Pos_termine_sur_erreur = 0 ($100)\n'       MAJ bit Erreur_de_poursuite = 0 ($2000)\n BG~e;'     Execution du mouvement\nENDIF\nStat[iCO]=(Stat[iCO]&@COM[$3000]);' MAJ bit Erreur_de_poursuite = 0 ($2000)\n'      MAJ bit Attente_de_correction = 0 ($1000)\nJP#CORCHK\n'\n'Si mouvement arrete par commande Stop\n#CORSTOP\n Stat[iCO]=(Stat[iCO]|$80)&@COM[$1000]\n'      MAJ bit Positionnement_termine = 1 ($80)\n'      MAJ bit Attente_de_correction = 0 ($1000)\nJP#CORCHK\n'\n'Si l'axe est toujours en erreur\n#CORFAIL\n Stat[iCO]=(Stat[iCO]|$2180)&@COM[$1000]\n'      MAJ bit Positionnement_termine = 1 ($80)\n'      MAJ bit Pos_termine_sur_erreur = 1 ($100)\n'      MAJ bit Attente_de_correction = 0 ($1000)\n'      MAJ bit Erreur_de_poursuite = 1 ($2000)\n#CORCHK\n' Boucle de traitement des axes en attente de correction\niCO=0;iCO8=8;iCO16=16;~e=0;'  Initialisation pointeur de tableau et d'axe\n#CORLOOP\nJP#PECORR,(Stat[iCO]&$1000)>0;' Si Attente_de_correction, correction ($1000)\niCO=iCO+1;iCO8=iCO8+1;iCO16=iCO16+1;~e=iCO;' Increment pointeur tableau et axe\nJP#CORLOOP,(iCO<8);'   Controle des 8 axes\n' Sortie de la tache lorsque l'erreur a ete traitee sur tous les axes\nEN\n'\n'######################## FIN DU MICROCODE GENERIQUE ########################\n'\n'===== Routine d'initialisation et declaration des variables specifiques =====\n#INITSPE;' !!! ne pas supprimer !!!\n'declaration des tableaux du microcode specifique\n' ...\n'initialisation des variables et des tableaux specifiques\n' ...\n LastAxis=-1;' Pointeur du dernier axe sur lequel un mouvement a ete commande\n'\n'Les tableaux sont indexes pas la variable iSPE (comprise entre 0 et 7)\n'-ici le microcode specifique peut etre declare comme etant actif :\n'   sur l'axe iSPE :   Stat[iSPE]=(Stat[iSPE]|$10)\n'-ici peut etre interdit le MotorOn/Off au device :\n'   pour l'axe iSPE :  Stat[iSPE]=(Stat[iSPE]&@COM[$20])\n'-ici peuvent etre interdits les mouvements au device :\n'   pour l'axe iSPE :  Stat[iSPE]=(Stat[iSPE]&@COM[$40])\n'-ici peut etre desactive le mode remote pour l'axe iSPE condidere :\n' EnRem[iSPE]=0;' Mote remote interdit par le Microcode\n'-ici peut figurer une commande d'execution d'une tache specifique du type :\n'   XQ#SPE_TSK,7\n'\nEN;'  !!! ne pas supprimer !!!\n'\n'================= Tache Specifique executee par #INITSPE ===================\n'#SPE_TSK\n' ...\n'EN\n'\n'=== Routine Specifique appelee sequentiellement par la boucle principale ===\n'#SPE_SEQ\n' ...\n'EN"
